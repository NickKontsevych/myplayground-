import {
  Buffer,
  __commonJS,
  __require,
  init_buffer,
  init_virtual_process_polyfill,
  process,
  require_build,
  require_build2,
  require_build3
} from "./chunk-BCR7QNX7.js";

// node_modules/@jest/expect-utils/build/jasmineUtils.js
var require_jasmineUtils = __commonJS({
  "node_modules/@jest/expect-utils/build/jasmineUtils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.equals = void 0;
    exports.isA = isA;
    var equals = (a, b, customTesters, strictCheck) => {
      customTesters = customTesters || [];
      return eq(a, b, [], [], customTesters, strictCheck);
    };
    exports.equals = equals;
    function isAsymmetric(obj) {
      return !!obj && isA("Function", obj.asymmetricMatch);
    }
    function asymmetricMatch(a, b) {
      const asymmetricA = isAsymmetric(a);
      const asymmetricB = isAsymmetric(b);
      if (asymmetricA && asymmetricB) {
        return void 0;
      }
      if (asymmetricA) {
        return a.asymmetricMatch(b);
      }
      if (asymmetricB) {
        return b.asymmetricMatch(a);
      }
    }
    function eq(a, b, aStack, bStack, customTesters, strictCheck) {
      let result = true;
      const asymmetricResult = asymmetricMatch(a, b);
      if (asymmetricResult !== void 0) {
        return asymmetricResult;
      }
      for (let i = 0; i < customTesters.length; i++) {
        const customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== void 0) {
          return customTesterResult;
        }
      }
      if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
      }
      if (Object.is(a, b)) {
        return true;
      }
      if (a === null || b === null) {
        return a === b;
      }
      const className = Object.prototype.toString.call(a);
      if (className != Object.prototype.toString.call(b)) {
        return false;
      }
      switch (className) {
        case "[object Boolean]":
        case "[object String]":
        case "[object Number]":
          if (typeof a !== typeof b) {
            return false;
          } else if (typeof a !== "object" && typeof b !== "object") {
            return Object.is(a, b);
          } else {
            return Object.is(a.valueOf(), b.valueOf());
          }
        case "[object Date]":
          return +a == +b;
        case "[object RegExp]":
          return a.source === b.source && a.flags === b.flags;
      }
      if (typeof a !== "object" || typeof b !== "object") {
        return false;
      }
      if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
      }
      let length = aStack.length;
      while (length--) {
        if (aStack[length] === a) {
          return bStack[length] === b;
        } else if (bStack[length] === b) {
          return false;
        }
      }
      aStack.push(a);
      bStack.push(b);
      if (strictCheck && className == "[object Array]" && a.length !== b.length) {
        return false;
      }
      const aKeys = keys(a, hasKey);
      let key;
      const bKeys = keys(b, hasKey);
      if (!strictCheck) {
        for (let index = 0; index !== bKeys.length; ++index) {
          key = bKeys[index];
          if ((isAsymmetric(b[key]) || b[key] === void 0) && !hasKey(a, key)) {
            aKeys.push(key);
          }
        }
        for (let index = 0; index !== aKeys.length; ++index) {
          key = aKeys[index];
          if ((isAsymmetric(a[key]) || a[key] === void 0) && !hasKey(b, key)) {
            bKeys.push(key);
          }
        }
      }
      let size = aKeys.length;
      if (bKeys.length !== size) {
        return false;
      }
      while (size--) {
        key = aKeys[size];
        if (strictCheck)
          result = hasKey(b, key) && eq(a[key], b[key], aStack, bStack, customTesters, strictCheck);
        else
          result = (hasKey(b, key) || isAsymmetric(a[key]) || a[key] === void 0) && eq(a[key], b[key], aStack, bStack, customTesters, strictCheck);
        if (!result) {
          return false;
        }
      }
      aStack.pop();
      bStack.pop();
      return result;
    }
    function keys(obj, hasKey2) {
      const keys2 = [];
      for (const key in obj) {
        if (hasKey2(obj, key)) {
          keys2.push(key);
        }
      }
      return keys2.concat(
        Object.getOwnPropertySymbols(obj).filter(
          (symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable
        )
      );
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function isA(typeName, value) {
      return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
    }
    function isDomNode(obj) {
      return obj !== null && typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string" && typeof obj.isEqualNode === "function";
    }
  }
});

// node_modules/@jest/expect-utils/build/immutableUtils.js
var require_immutableUtils = __commonJS({
  "node_modules/@jest/expect-utils/build/immutableUtils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isImmutableList = isImmutableList;
    exports.isImmutableOrderedKeyed = isImmutableOrderedKeyed;
    exports.isImmutableOrderedSet = isImmutableOrderedSet;
    exports.isImmutableRecord = isImmutableRecord;
    exports.isImmutableUnorderedKeyed = isImmutableUnorderedKeyed;
    exports.isImmutableUnorderedSet = isImmutableUnorderedSet;
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
    function isObjectLiteral(source) {
      return source != null && typeof source === "object" && !Array.isArray(source);
    }
    function isImmutableUnorderedKeyed(source) {
      return Boolean(
        source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL] && !source[IS_ORDERED_SENTINEL]
      );
    }
    function isImmutableUnorderedSet(source) {
      return Boolean(
        source && isObjectLiteral(source) && source[IS_SET_SENTINEL] && !source[IS_ORDERED_SENTINEL]
      );
    }
    function isImmutableList(source) {
      return Boolean(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL]);
    }
    function isImmutableOrderedKeyed(source) {
      return Boolean(
        source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL] && source[IS_ORDERED_SENTINEL]
      );
    }
    function isImmutableOrderedSet(source) {
      return Boolean(
        source && isObjectLiteral(source) && source[IS_SET_SENTINEL] && source[IS_ORDERED_SENTINEL]
      );
    }
    function isImmutableRecord(source) {
      return Boolean(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL]);
    }
  }
});

// node_modules/@jest/expect-utils/build/utils.js
var require_utils = __commonJS({
  "node_modules/@jest/expect-utils/build/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.arrayBufferEquality = void 0;
    exports.emptyObject = emptyObject;
    exports.typeEquality = exports.subsetEquality = exports.sparseArrayEquality = exports.pathAsArray = exports.partition = exports.iterableEquality = exports.isOneline = exports.isError = exports.getPath = exports.getObjectSubset = void 0;
    var _jestGetType = require_build();
    var _immutableUtils = require_immutableUtils();
    var _jasmineUtils = require_jasmineUtils();
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var hasPropertyInObject = (object, key) => {
      const shouldTerminate = !object || typeof object !== "object" || object === Object.prototype;
      if (shouldTerminate) {
        return false;
      }
      return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
    };
    var getPath = (object, propertyPath) => {
      if (!Array.isArray(propertyPath)) {
        propertyPath = pathAsArray(propertyPath);
      }
      if (propertyPath.length) {
        const lastProp = propertyPath.length === 1;
        const prop = propertyPath[0];
        const newObject = object[prop];
        if (!lastProp && (newObject === null || newObject === void 0)) {
          return {
            hasEndProp: false,
            lastTraversedObject: object,
            traversedPath: []
          };
        }
        const result = getPath(newObject, propertyPath.slice(1));
        if (result.lastTraversedObject === null) {
          result.lastTraversedObject = object;
        }
        result.traversedPath.unshift(prop);
        if (lastProp) {
          result.endPropIsDefined = !(0, _jestGetType.isPrimitive)(object) && prop in object;
          result.hasEndProp = newObject !== void 0 || result.endPropIsDefined;
          if (!result.hasEndProp) {
            result.traversedPath.shift();
          }
        }
        return result;
      }
      return {
        lastTraversedObject: null,
        traversedPath: [],
        value: object
      };
    };
    exports.getPath = getPath;
    var getObjectSubset = (object, subset, seenReferences = /* @__PURE__ */ new WeakMap()) => {
      if (Array.isArray(object)) {
        if (Array.isArray(subset) && subset.length === object.length) {
          return subset.map((sub, i) => getObjectSubset(object[i], sub));
        }
      } else if (object instanceof Date) {
        return object;
      } else if (isObject(object) && isObject(subset)) {
        if ((0, _jasmineUtils.equals)(object, subset, [
          iterableEquality,
          subsetEquality
        ])) {
          return subset;
        }
        const trimmed = {};
        seenReferences.set(object, trimmed);
        Object.keys(object).filter((key) => hasPropertyInObject(subset, key)).forEach((key) => {
          trimmed[key] = seenReferences.has(object[key]) ? seenReferences.get(object[key]) : getObjectSubset(object[key], subset[key], seenReferences);
        });
        if (Object.keys(trimmed).length > 0) {
          return trimmed;
        }
      }
      return object;
    };
    exports.getObjectSubset = getObjectSubset;
    var IteratorSymbol = Symbol2.iterator;
    var hasIterator = (object) => !!(object != null && object[IteratorSymbol]);
    var iterableEquality = (a, b, aStack = [], bStack = []) => {
      if (typeof a !== "object" || typeof b !== "object" || Array.isArray(a) || Array.isArray(b) || !hasIterator(a) || !hasIterator(b)) {
        return void 0;
      }
      if (a.constructor !== b.constructor) {
        return false;
      }
      let length = aStack.length;
      while (length--) {
        if (aStack[length] === a) {
          return bStack[length] === b;
        }
      }
      aStack.push(a);
      bStack.push(b);
      const iterableEqualityWithStack = (a2, b2) => iterableEquality(a2, b2, [...aStack], [...bStack]);
      if (a.size !== void 0) {
        if (a.size !== b.size) {
          return false;
        } else if ((0, _jasmineUtils.isA)("Set", a) || (0, _immutableUtils.isImmutableUnorderedSet)(a)) {
          let allFound = true;
          for (const aValue of a) {
            if (!b.has(aValue)) {
              let has = false;
              for (const bValue of b) {
                const isEqual = (0, _jasmineUtils.equals)(aValue, bValue, [
                  iterableEqualityWithStack
                ]);
                if (isEqual === true) {
                  has = true;
                }
              }
              if (has === false) {
                allFound = false;
                break;
              }
            }
          }
          aStack.pop();
          bStack.pop();
          return allFound;
        } else if ((0, _jasmineUtils.isA)("Map", a) || (0, _immutableUtils.isImmutableUnorderedKeyed)(a)) {
          let allFound = true;
          for (const aEntry of a) {
            if (!b.has(aEntry[0]) || !(0, _jasmineUtils.equals)(aEntry[1], b.get(aEntry[0]), [
              iterableEqualityWithStack
            ])) {
              let has = false;
              for (const bEntry of b) {
                const matchedKey = (0, _jasmineUtils.equals)(aEntry[0], bEntry[0], [
                  iterableEqualityWithStack
                ]);
                let matchedValue = false;
                if (matchedKey === true) {
                  matchedValue = (0, _jasmineUtils.equals)(aEntry[1], bEntry[1], [
                    iterableEqualityWithStack
                  ]);
                }
                if (matchedValue === true) {
                  has = true;
                }
              }
              if (has === false) {
                allFound = false;
                break;
              }
            }
          }
          aStack.pop();
          bStack.pop();
          return allFound;
        }
      }
      const bIterator = b[IteratorSymbol]();
      for (const aValue of a) {
        const nextB = bIterator.next();
        if (nextB.done || !(0, _jasmineUtils.equals)(aValue, nextB.value, [
          iterableEqualityWithStack
        ])) {
          return false;
        }
      }
      if (!bIterator.next().done) {
        return false;
      }
      if (!(0, _immutableUtils.isImmutableList)(a) && !(0, _immutableUtils.isImmutableOrderedKeyed)(a) && !(0, _immutableUtils.isImmutableOrderedSet)(a) && !(0, _immutableUtils.isImmutableRecord)(a)) {
        const aEntries = Object.entries(a);
        const bEntries = Object.entries(b);
        if (!(0, _jasmineUtils.equals)(aEntries, bEntries)) {
          return false;
        }
      }
      aStack.pop();
      bStack.pop();
      return true;
    };
    exports.iterableEquality = iterableEquality;
    var isObject = (a) => a !== null && typeof a === "object";
    var isObjectWithKeys = (a) => isObject(a) && !(a instanceof Error) && !(a instanceof Array) && !(a instanceof Date);
    var subsetEquality = (object, subset) => {
      const subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
        if (!isObjectWithKeys(subset2)) {
          return void 0;
        }
        return Object.keys(subset2).every((key) => {
          if (isObjectWithKeys(subset2[key])) {
            if (seenReferences.has(subset2[key])) {
              return (0, _jasmineUtils.equals)(object2[key], subset2[key], [
                iterableEquality
              ]);
            }
            seenReferences.set(subset2[key], true);
          }
          const result = object2 != null && hasPropertyInObject(object2, key) && (0, _jasmineUtils.equals)(object2[key], subset2[key], [
            iterableEquality,
            subsetEqualityWithContext(seenReferences)
          ]);
          seenReferences.delete(subset2[key]);
          return result;
        });
      };
      return subsetEqualityWithContext()(object, subset);
    };
    exports.subsetEquality = subsetEquality;
    var typeEquality = (a, b) => {
      if (a == null || b == null || a.constructor === b.constructor) {
        return void 0;
      }
      return false;
    };
    exports.typeEquality = typeEquality;
    var arrayBufferEquality = (a, b) => {
      if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer)) {
        return void 0;
      }
      const dataViewA = new DataView(a);
      const dataViewB = new DataView(b);
      if (dataViewA.byteLength !== dataViewB.byteLength) {
        return false;
      }
      for (let i = 0; i < dataViewA.byteLength; i++) {
        if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {
          return false;
        }
      }
      return true;
    };
    exports.arrayBufferEquality = arrayBufferEquality;
    var sparseArrayEquality = (a, b) => {
      if (!Array.isArray(a) || !Array.isArray(b)) {
        return void 0;
      }
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      return (0, _jasmineUtils.equals)(a, b, [iterableEquality, typeEquality], true) && (0, _jasmineUtils.equals)(aKeys, bKeys);
    };
    exports.sparseArrayEquality = sparseArrayEquality;
    var partition = (items, predicate) => {
      const result = [[], []];
      items.forEach((item) => result[predicate(item) ? 0 : 1].push(item));
      return result;
    };
    exports.partition = partition;
    var pathAsArray = (propertyPath) => {
      const properties = [];
      if (propertyPath === "") {
        properties.push("");
        return properties;
      }
      const pattern = RegExp("[^.[\\]]+|(?=(?:\\.)(?:\\.|$))", "g");
      if (propertyPath[0] === ".") {
        properties.push("");
      }
      propertyPath.replace(pattern, (match) => {
        properties.push(match);
        return match;
      });
      return properties;
    };
    exports.pathAsArray = pathAsArray;
    var isError = (value) => {
      switch (Object.prototype.toString.call(value)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
          return true;
        default:
          return value instanceof Error;
      }
    };
    exports.isError = isError;
    function emptyObject(obj) {
      return obj && typeof obj === "object" ? !Object.keys(obj).length : false;
    }
    var MULTILINE_REGEXP = /[\r\n]/;
    var isOneline = (expected, received) => typeof expected === "string" && typeof received === "string" && (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));
    exports.isOneline = isOneline;
  }
});

// node_modules/@jest/expect-utils/build/index.js
var require_build4 = __commonJS({
  "node_modules/@jest/expect-utils/build/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      equals: true,
      isA: true
    };
    Object.defineProperty(exports, "equals", {
      enumerable: true,
      get: function() {
        return _jasmineUtils.equals;
      }
    });
    Object.defineProperty(exports, "isA", {
      enumerable: true,
      get: function() {
        return _jasmineUtils.isA;
      }
    });
    var _jasmineUtils = require_jasmineUtils();
    var _utils = require_utils();
    Object.keys(_utils).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _utils[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _utils[key];
        }
      });
    });
  }
});

// node_modules/jest-util/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/jest-util/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/jest-util/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/jest-util/node_modules/color-convert/conversions.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/jest-util/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/jest-util/node_modules/color-convert/route.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/jest-util/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/jest-util/node_modules/color-convert/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/jest-util/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/jest-util/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/jest-util/node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/jest-util/node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/jest-util/node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/jest-util/node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/jest-util/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/jest-util/node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/jest-util/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/jest-util/node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});

// node_modules/jest-util/build/clearLine.js
var require_clearLine = __commonJS({
  "node_modules/jest-util/build/clearLine.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clearLine;
    function clearLine(stream) {
      if (stream.isTTY) {
        stream.write("\x1B[999D\x1B[K");
      }
    }
  }
});

// node_modules/ci-info/vendors.json
var require_vendors = __commonJS({
  "node_modules/ci-info/vendors.json"(exports, module) {
    module.exports = [
      {
        name: "Appcircle",
        constant: "APPCIRCLE",
        env: "AC_APPCIRCLE"
      },
      {
        name: "AppVeyor",
        constant: "APPVEYOR",
        env: "APPVEYOR",
        pr: "APPVEYOR_PULL_REQUEST_NUMBER"
      },
      {
        name: "AWS CodeBuild",
        constant: "CODEBUILD",
        env: "CODEBUILD_BUILD_ARN"
      },
      {
        name: "Azure Pipelines",
        constant: "AZURE_PIPELINES",
        env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
        pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
      },
      {
        name: "Bamboo",
        constant: "BAMBOO",
        env: "bamboo_planKey"
      },
      {
        name: "Bitbucket Pipelines",
        constant: "BITBUCKET",
        env: "BITBUCKET_COMMIT",
        pr: "BITBUCKET_PR_ID"
      },
      {
        name: "Bitrise",
        constant: "BITRISE",
        env: "BITRISE_IO",
        pr: "BITRISE_PULL_REQUEST"
      },
      {
        name: "Buddy",
        constant: "BUDDY",
        env: "BUDDY_WORKSPACE_ID",
        pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
      },
      {
        name: "Buildkite",
        constant: "BUILDKITE",
        env: "BUILDKITE",
        pr: { env: "BUILDKITE_PULL_REQUEST", ne: "false" }
      },
      {
        name: "CircleCI",
        constant: "CIRCLE",
        env: "CIRCLECI",
        pr: "CIRCLE_PULL_REQUEST"
      },
      {
        name: "Cirrus CI",
        constant: "CIRRUS",
        env: "CIRRUS_CI",
        pr: "CIRRUS_PR"
      },
      {
        name: "Codefresh",
        constant: "CODEFRESH",
        env: "CF_BUILD_ID",
        pr: { any: ["CF_PULL_REQUEST_NUMBER", "CF_PULL_REQUEST_ID"] }
      },
      {
        name: "Codemagic",
        constant: "CODEMAGIC",
        env: "CM_BUILD_ID",
        pr: "CM_PULL_REQUEST"
      },
      {
        name: "Codeship",
        constant: "CODESHIP",
        env: { CI_NAME: "codeship" }
      },
      {
        name: "Drone",
        constant: "DRONE",
        env: "DRONE",
        pr: { DRONE_BUILD_EVENT: "pull_request" }
      },
      {
        name: "dsari",
        constant: "DSARI",
        env: "DSARI"
      },
      {
        name: "Expo Application Services",
        constant: "EAS",
        env: "EAS_BUILD"
      },
      {
        name: "GitHub Actions",
        constant: "GITHUB_ACTIONS",
        env: "GITHUB_ACTIONS",
        pr: { GITHUB_EVENT_NAME: "pull_request" }
      },
      {
        name: "GitLab CI",
        constant: "GITLAB",
        env: "GITLAB_CI",
        pr: "CI_MERGE_REQUEST_ID"
      },
      {
        name: "GoCD",
        constant: "GOCD",
        env: "GO_PIPELINE_LABEL"
      },
      {
        name: "Google Cloud Build",
        constant: "GOOGLE_CLOUD_BUILD",
        env: "BUILDER_OUTPUT"
      },
      {
        name: "LayerCI",
        constant: "LAYERCI",
        env: "LAYERCI",
        pr: "LAYERCI_PULL_REQUEST"
      },
      {
        name: "Gerrit",
        constant: "GERRIT",
        env: "GERRIT_PROJECT"
      },
      {
        name: "Heroku",
        constant: "HEROKU",
        env: { env: "NODE", includes: "/app/.heroku/node/bin/node" }
      },
      {
        name: "Hudson",
        constant: "HUDSON",
        env: "HUDSON_URL"
      },
      {
        name: "Jenkins",
        constant: "JENKINS",
        env: ["JENKINS_URL", "BUILD_ID"],
        pr: { any: ["ghprbPullId", "CHANGE_ID"] }
      },
      {
        name: "Magnum CI",
        constant: "MAGNUM",
        env: "MAGNUM"
      },
      {
        name: "Netlify CI",
        constant: "NETLIFY",
        env: "NETLIFY",
        pr: { env: "PULL_REQUEST", ne: "false" }
      },
      {
        name: "Nevercode",
        constant: "NEVERCODE",
        env: "NEVERCODE",
        pr: { env: "NEVERCODE_PULL_REQUEST", ne: "false" }
      },
      {
        name: "ReleaseHub",
        constant: "RELEASEHUB",
        env: "RELEASE_BUILD_ID"
      },
      {
        name: "Render",
        constant: "RENDER",
        env: "RENDER",
        pr: { IS_PULL_REQUEST: "true" }
      },
      {
        name: "Sail CI",
        constant: "SAIL",
        env: "SAILCI",
        pr: "SAIL_PULL_REQUEST_NUMBER"
      },
      {
        name: "Screwdriver",
        constant: "SCREWDRIVER",
        env: "SCREWDRIVER",
        pr: { env: "SD_PULL_REQUEST", ne: "false" }
      },
      {
        name: "Semaphore",
        constant: "SEMAPHORE",
        env: "SEMAPHORE",
        pr: "PULL_REQUEST_NUMBER"
      },
      {
        name: "Shippable",
        constant: "SHIPPABLE",
        env: "SHIPPABLE",
        pr: { IS_PULL_REQUEST: "true" }
      },
      {
        name: "Solano CI",
        constant: "SOLANO",
        env: "TDDIUM",
        pr: "TDDIUM_PR_ID"
      },
      {
        name: "Sourcehut",
        constant: "SOURCEHUT",
        env: { CI_NAME: "sourcehut" }
      },
      {
        name: "Strider CD",
        constant: "STRIDER",
        env: "STRIDER"
      },
      {
        name: "TaskCluster",
        constant: "TASKCLUSTER",
        env: ["TASK_ID", "RUN_ID"]
      },
      {
        name: "TeamCity",
        constant: "TEAMCITY",
        env: "TEAMCITY_VERSION"
      },
      {
        name: "Travis CI",
        constant: "TRAVIS",
        env: "TRAVIS",
        pr: { env: "TRAVIS_PULL_REQUEST", ne: "false" }
      },
      {
        name: "Vercel",
        constant: "VERCEL",
        env: { any: ["NOW_BUILDER", "VERCEL"] }
      },
      {
        name: "Visual Studio App Center",
        constant: "APPCENTER",
        env: "APPCENTER_BUILD_ID"
      },
      {
        name: "Woodpecker",
        constant: "WOODPECKER",
        env: { CI: "woodpecker" },
        pr: { CI_BUILD_EVENT: "pull_request" }
      },
      {
        name: "Xcode Cloud",
        constant: "XCODE_CLOUD",
        env: "CI_XCODE_PROJECT",
        pr: "CI_PULL_REQUEST_NUMBER"
      },
      {
        name: "Xcode Server",
        constant: "XCODE_SERVER",
        env: "XCS"
      }
    ];
  }
});

// node_modules/ci-info/index.js
var require_ci_info = __commonJS({
  "node_modules/ci-info/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var vendors = require_vendors();
    var env = process.env;
    Object.defineProperty(exports, "_vendors", {
      value: vendors.map(function(v) {
        return v.constant;
      })
    });
    exports.name = null;
    exports.isPR = null;
    vendors.forEach(function(vendor) {
      const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
      const isCI = envs.every(function(obj) {
        return checkEnv(obj);
      });
      exports[vendor.constant] = isCI;
      if (!isCI) {
        return;
      }
      exports.name = vendor.name;
      switch (typeof vendor.pr) {
        case "string":
          exports.isPR = !!env[vendor.pr];
          break;
        case "object":
          if ("env" in vendor.pr) {
            exports.isPR = vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne;
          } else if ("any" in vendor.pr) {
            exports.isPR = vendor.pr.any.some(function(key) {
              return !!env[key];
            });
          } else {
            exports.isPR = checkEnv(vendor.pr);
          }
          break;
        default:
          exports.isPR = null;
      }
    });
    exports.isCI = !!(env.BUILD_ID || env.BUILD_NUMBER || env.CI || env.CI_APP_ID || env.CI_BUILD_ID || env.CI_BUILD_NUMBER || env.CI_NAME || env.CONTINUOUS_INTEGRATION || env.RUN_ID || exports.name || false);
    function checkEnv(obj) {
      if (typeof obj === "string")
        return !!env[obj];
      if ("env" in obj) {
        return env[obj.env] && env[obj.env].includes(obj.includes);
      }
      if ("any" in obj) {
        return obj.any.some(function(k) {
          return !!env[k];
        });
      }
      return Object.keys(obj).every(function(k) {
        return env[k] === obj[k];
      });
    }
  }
});

// node_modules/jest-util/build/isInteractive.js
var require_isInteractive = __commonJS({
  "node_modules/jest-util/build/isInteractive.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _ciInfo() {
      const data = require_ci_info();
      _ciInfo = function() {
        return data;
      };
      return data;
    }
    var _default = !!process.stdout.isTTY && process.env.TERM !== "dumb" && !_ciInfo().isCI;
    exports.default = _default;
  }
});

// node_modules/jest-util/build/preRunMessage.js
var require_preRunMessage = __commonJS({
  "node_modules/jest-util/build/preRunMessage.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.print = print;
    exports.remove = remove;
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    var _clearLine = _interopRequireDefault(require_clearLine());
    var _isInteractive = _interopRequireDefault(require_isInteractive());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function print(stream) {
      if (_isInteractive.default) {
        stream.write(
          _chalk().default.bold.dim("Determining test suites to run...")
        );
      }
    }
    function remove(stream) {
      if (_isInteractive.default) {
        (0, _clearLine.default)(stream);
      }
    }
  }
});

// node_modules/jest-util/build/specialChars.js
var require_specialChars = __commonJS({
  "node_modules/jest-util/build/specialChars.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ICONS = exports.CLEAR = exports.ARROW = void 0;
    var isWindows = process.platform === "win32";
    var ARROW = " \u203A ";
    exports.ARROW = ARROW;
    var ICONS = {
      failed: isWindows ? "\xD7" : "\u2715",
      pending: "\u25CB",
      success: isWindows ? "\u221A" : "\u2713",
      todo: "\u270E"
    };
    exports.ICONS = ICONS;
    var CLEAR = isWindows ? "\x1B[2J\x1B[0f" : "\x1B[2J\x1B[3J\x1B[H";
    exports.CLEAR = CLEAR;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var constants = require_constants();
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Stream = require_stream().Stream;
    module.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// browser-external:util
var require_util2 = __commonJS({
  "browser-external:util"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var fs = require_fs();
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require_util2();
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = globalThis[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require_assert().equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!globalThis[gracefulQueue]) {
      publishQueue(globalThis, fs[gracefulQueue]);
    }
    module.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/jest-util/build/createDirectory.js
var require_createDirectory = __commonJS({
  "node_modules/jest-util/build/createDirectory.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createDirectory;
    function fs() {
      const data = _interopRequireWildcard(require_graceful_fs());
      fs = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function createDirectory(path) {
      try {
        fs().mkdirSync(path, {
          recursive: true
        });
      } catch (e) {
        if (e.code !== "EEXIST") {
          throw e;
        }
      }
    }
  }
});

// node_modules/jest-util/build/ErrorWithStack.js
var require_ErrorWithStack = __commonJS({
  "node_modules/jest-util/build/ErrorWithStack.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ErrorWithStack = class extends Error {
      constructor(message, callsite, stackLimit) {
        const originalStackLimit = Error.stackTraceLimit;
        if (stackLimit) {
          Error.stackTraceLimit = Math.max(stackLimit, originalStackLimit || 10);
        }
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, callsite);
        }
        Error.stackTraceLimit = originalStackLimit;
      }
    };
    exports.default = ErrorWithStack;
  }
});

// node_modules/jest-util/build/deepCyclicCopy.js
var require_deepCyclicCopy = __commonJS({
  "node_modules/jest-util/build/deepCyclicCopy.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deepCyclicCopy;
    var EMPTY = /* @__PURE__ */ new Set();
    function deepCyclicCopy(value, options = {
      blacklist: EMPTY,
      keepPrototype: false
    }, cycles = /* @__PURE__ */ new WeakMap()) {
      if (typeof value !== "object" || value === null || Buffer.isBuffer(value)) {
        return value;
      } else if (cycles.has(value)) {
        return cycles.get(value);
      } else if (Array.isArray(value)) {
        return deepCyclicCopyArray(value, options, cycles);
      } else {
        return deepCyclicCopyObject(value, options, cycles);
      }
    }
    function deepCyclicCopyObject(object, options, cycles) {
      const newObject = options.keepPrototype ? Object.create(Object.getPrototypeOf(object)) : {};
      const descriptors = Object.getOwnPropertyDescriptors(object);
      cycles.set(object, newObject);
      Object.keys(descriptors).forEach((key) => {
        if (options.blacklist && options.blacklist.has(key)) {
          delete descriptors[key];
          return;
        }
        const descriptor = descriptors[key];
        if (typeof descriptor.value !== "undefined") {
          descriptor.value = deepCyclicCopy(
            descriptor.value,
            {
              blacklist: EMPTY,
              keepPrototype: options.keepPrototype
            },
            cycles
          );
        }
        descriptor.configurable = true;
      });
      return Object.defineProperties(newObject, descriptors);
    }
    function deepCyclicCopyArray(array, options, cycles) {
      const newArray = options.keepPrototype ? new (Object.getPrototypeOf(array)).constructor(array.length) : [];
      const length = array.length;
      cycles.set(array, newArray);
      for (let i = 0; i < length; i++) {
        newArray[i] = deepCyclicCopy(
          array[i],
          {
            blacklist: EMPTY,
            keepPrototype: options.keepPrototype
          },
          cycles
        );
      }
      return newArray;
    }
  }
});

// browser-external:process
var require_process = __commonJS({
  "browser-external:process"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "process" has been externalized for browser compatibility. Cannot access "process.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/jest-util/build/createProcessObject.js
var require_createProcessObject = __commonJS({
  "node_modules/jest-util/build/createProcessObject.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createProcessObject;
    var _deepCyclicCopy = _interopRequireDefault(require_deepCyclicCopy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BLACKLIST = /* @__PURE__ */ new Set(["env", "mainModule", "_events"]);
    var isWin32 = process.platform === "win32";
    var proto = Object.getPrototypeOf(process.env);
    function createProcessEnv() {
      const real = Object.create(proto);
      const lookup = {};
      function deletePropertyWin32(_target, key) {
        for (const name in real) {
          if (Object.prototype.hasOwnProperty.call(real, name)) {
            if (typeof key === "string") {
              if (name.toLowerCase() === key.toLowerCase()) {
                delete real[name];
                delete lookup[name.toLowerCase()];
              }
            } else {
              if (key === name) {
                delete real[name];
                delete lookup[name];
              }
            }
          }
        }
        return true;
      }
      function deleteProperty(_target, key) {
        delete real[key];
        delete lookup[key];
        return true;
      }
      function getProperty(_target, key) {
        return real[key];
      }
      function getPropertyWin32(_target, key) {
        if (typeof key === "string") {
          return lookup[key in proto ? key : key.toLowerCase()];
        } else {
          return real[key];
        }
      }
      const proxy = new Proxy(real, {
        deleteProperty: isWin32 ? deletePropertyWin32 : deleteProperty,
        get: isWin32 ? getPropertyWin32 : getProperty,
        set(_target, key, value) {
          const strValue = `${value}`;
          if (typeof key === "string") {
            lookup[key.toLowerCase()] = strValue;
          }
          real[key] = strValue;
          return true;
        }
      });
      return Object.assign(proxy, process.env);
    }
    function createProcessObject() {
      const process2 = require_process();
      const newProcess = (0, _deepCyclicCopy.default)(process2, {
        blacklist: BLACKLIST,
        keepPrototype: true
      });
      try {
        newProcess[Symbol.toStringTag] = "process";
      } catch (e) {
        if (newProcess[Symbol.toStringTag] !== "process") {
          e.message = `Unable to set toStringTag on process. Please open up an issue at https://github.com/facebook/jest

${e.message}`;
          throw e;
        }
      }
      let proto2 = process2;
      while (proto2 = Object.getPrototypeOf(proto2)) {
        if (typeof proto2.constructor === "function") {
          proto2.constructor.call(newProcess);
        }
      }
      newProcess.env = createProcessEnv();
      newProcess.send = () => true;
      Object.defineProperty(newProcess, "domain", {
        get() {
          return process2.domain;
        }
      });
      return newProcess;
    }
  }
});

// node_modules/jest-util/build/installCommonGlobals.js
var require_installCommonGlobals = __commonJS({
  "node_modules/jest-util/build/installCommonGlobals.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = installCommonGlobals;
    function fs() {
      const data = _interopRequireWildcard(require_graceful_fs());
      fs = function() {
        return data;
      };
      return data;
    }
    var _createProcessObject = _interopRequireDefault(
      require_createProcessObject()
    );
    var _deepCyclicCopy = _interopRequireDefault(require_deepCyclicCopy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var DTRACE = Object.keys(globalThis).filter((key) => key.startsWith("DTRACE"));
    function installCommonGlobals(globalObject, globals) {
      globalObject.process = (0, _createProcessObject.default)();
      const symbol = globalObject.Symbol;
      Object.defineProperties(globalObject, {
        [symbol.for("jest-native-promise")]: {
          enumerable: false,
          value: Promise,
          writable: false
        },
        [symbol.for("jest-native-now")]: {
          enumerable: false,
          value: globalObject.Date.now.bind(globalObject.Date),
          writable: false
        },
        [symbol.for("jest-native-read-file")]: {
          enumerable: false,
          value: fs().readFileSync.bind(fs()),
          writable: false
        },
        [symbol.for("jest-native-write-file")]: {
          enumerable: false,
          value: fs().writeFileSync.bind(fs()),
          writable: false
        },
        [symbol.for("jest-native-exists-file")]: {
          enumerable: false,
          value: fs().existsSync.bind(fs()),
          writable: false
        },
        "jest-symbol-do-not-touch": {
          enumerable: false,
          value: symbol,
          writable: false
        }
      });
      DTRACE.forEach((dtrace) => {
        globalObject[dtrace] = function(...args) {
          return globalThis[dtrace].apply(this, args);
        };
      });
      return Object.assign(globalObject, (0, _deepCyclicCopy.default)(globals));
    }
  }
});

// node_modules/jest-util/build/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/jest-util/build/interopRequireDefault.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = interopRequireDefault;
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  }
});

// node_modules/jest-util/build/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/jest-util/build/isPromise.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPromise;
    function isPromise(candidate) {
      return candidate != null && (typeof candidate === "object" || typeof candidate === "function") && typeof candidate.then === "function";
    }
  }
});

// node_modules/jest-util/build/setGlobal.js
var require_setGlobal = __commonJS({
  "node_modules/jest-util/build/setGlobal.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = setGlobal;
    function setGlobal(globalToMutate, key, value) {
      globalToMutate[key] = value;
    }
  }
});

// node_modules/jest-util/build/convertDescriptorToString.js
var require_convertDescriptorToString = __commonJS({
  "node_modules/jest-util/build/convertDescriptorToString.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = convertDescriptorToString;
    function convertDescriptorToString(descriptor) {
      switch (typeof descriptor) {
        case "function":
          if (descriptor.name) {
            return descriptor.name;
          }
          break;
        case "number":
        case "undefined":
          return `${descriptor}`;
        case "string":
          return descriptor;
      }
      throw new Error(
        `Invalid first argument, ${descriptor}. It must be a named class, named function, number, or string.`
      );
    }
  }
});

// node_modules/jest-util/build/replacePathSepForGlob.js
var require_replacePathSepForGlob = __commonJS({
  "node_modules/jest-util/build/replacePathSepForGlob.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = replacePathSepForGlob;
    function replacePathSepForGlob(path) {
      return path.replace(/\\(?![{}()+?.^$])/g, "/");
    }
  }
});

// node_modules/jest-util/build/testPathPatternToRegExp.js
var require_testPathPatternToRegExp = __commonJS({
  "node_modules/jest-util/build/testPathPatternToRegExp.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = testPathPatternToRegExp;
    function testPathPatternToRegExp(testPathPattern) {
      return new RegExp(testPathPattern, "i");
    }
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var path = require_path();
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var path = require_path();
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var path = require_path();
    var scan = require_scan();
    var parse = require_parse();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_picomatch();
  }
});

// node_modules/jest-util/build/globsToMatcher.js
var require_globsToMatcher = __commonJS({
  "node_modules/jest-util/build/globsToMatcher.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = globsToMatcher;
    function _picomatch() {
      const data = _interopRequireDefault(require_picomatch2());
      _picomatch = function() {
        return data;
      };
      return data;
    }
    var _replacePathSepForGlob = _interopRequireDefault(
      require_replacePathSepForGlob()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var globsToMatchersMap = /* @__PURE__ */ new Map();
    var picomatchOptions = {
      dot: true
    };
    function globsToMatcher(globs) {
      if (globs.length === 0) {
        return () => false;
      }
      const matchers = globs.map((glob) => {
        if (!globsToMatchersMap.has(glob)) {
          const isMatch = (0, _picomatch().default)(glob, picomatchOptions, true);
          const matcher = {
            isMatch,
            negated: isMatch.state.negated || !!isMatch.state.negatedExtglob
          };
          globsToMatchersMap.set(glob, matcher);
        }
        return globsToMatchersMap.get(glob);
      });
      return (path) => {
        const replacedPath = (0, _replacePathSepForGlob.default)(path);
        let kept = void 0;
        let negatives = 0;
        for (let i = 0; i < matchers.length; i++) {
          const { isMatch, negated } = matchers[i];
          if (negated) {
            negatives++;
          }
          const matched = isMatch(replacedPath);
          if (!matched && negated) {
            kept = false;
          } else if (matched && !negated) {
            kept = true;
          }
        }
        return negatives === matchers.length ? kept !== false : !!kept;
      };
    }
  }
});

// node_modules/jest-util/build/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/jest-util/build/pluralize.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = pluralize;
    function pluralize(word, count) {
      return `${count} ${word}${count === 1 ? "" : "s"}`;
    }
  }
});

// node_modules/jest-util/build/formatTime.js
var require_formatTime = __commonJS({
  "node_modules/jest-util/build/formatTime.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = formatTime;
    function formatTime(time, prefixPower = -3, padLeftLength = 0) {
      const prefixes = ["n", "\u03BC", "m", ""];
      const prefixIndex = Math.max(
        0,
        Math.min(
          Math.trunc(prefixPower / 3) + prefixes.length - 1,
          prefixes.length - 1
        )
      );
      return `${String(time).padStart(padLeftLength)} ${prefixes[prefixIndex]}s`;
    }
  }
});

// node_modules/jest-util/build/tryRealpath.js
var require_tryRealpath = __commonJS({
  "node_modules/jest-util/build/tryRealpath.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = tryRealpath;
    function _gracefulFs() {
      const data = require_graceful_fs();
      _gracefulFs = function() {
        return data;
      };
      return data;
    }
    function tryRealpath(path) {
      try {
        path = _gracefulFs().realpathSync.native(path);
      } catch (error) {
        if (error.code !== "ENOENT" && error.code !== "EISDIR") {
          throw error;
        }
      }
      return path;
    }
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/jest-util/build/requireOrImportModule.js
var require_requireOrImportModule = __commonJS({
  "node_modules/jest-util/build/requireOrImportModule.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = requireOrImportModule;
    function _path() {
      const data = require_path();
      _path = function() {
        return data;
      };
      return data;
    }
    function _url() {
      const data = require_url();
      _url = function() {
        return data;
      };
      return data;
    }
    var _interopRequireDefault = _interopRequireDefault2(
      require_interopRequireDefault()
    );
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function requireOrImportModule(filePath, applyInteropRequireDefault = true) {
      if (!(0, _path().isAbsolute)(filePath) && filePath[0] === ".") {
        throw new Error(
          `Jest: requireOrImportModule path must be absolute, was "${filePath}"`
        );
      }
      try {
        const requiredModule = __require(filePath);
        if (!applyInteropRequireDefault) {
          return requiredModule;
        }
        return (0, _interopRequireDefault.default)(requiredModule).default;
      } catch (error) {
        if (error.code === "ERR_REQUIRE_ESM") {
          try {
            const moduleUrl = (0, _url().pathToFileURL)(filePath);
            const importedModule = await import(moduleUrl.href);
            if (!applyInteropRequireDefault) {
              return importedModule;
            }
            if (!importedModule.default) {
              throw new Error(
                `Jest: Failed to load ESM at ${filePath} - did you use a default export?`
              );
            }
            return importedModule.default;
          } catch (innerError) {
            if (innerError.message === "Not supported") {
              throw new Error(
                `Jest: Your version of Node does not support dynamic import - please enable it or use a .cjs file extension for file ${filePath}`
              );
            }
            throw innerError;
          }
        } else {
          throw error;
        }
      }
    }
  }
});

// node_modules/jest-util/build/index.js
var require_build5 = __commonJS({
  "node_modules/jest-util/build/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ErrorWithStack", {
      enumerable: true,
      get: function() {
        return _ErrorWithStack.default;
      }
    });
    Object.defineProperty(exports, "clearLine", {
      enumerable: true,
      get: function() {
        return _clearLine.default;
      }
    });
    Object.defineProperty(exports, "convertDescriptorToString", {
      enumerable: true,
      get: function() {
        return _convertDescriptorToString.default;
      }
    });
    Object.defineProperty(exports, "createDirectory", {
      enumerable: true,
      get: function() {
        return _createDirectory.default;
      }
    });
    Object.defineProperty(exports, "deepCyclicCopy", {
      enumerable: true,
      get: function() {
        return _deepCyclicCopy.default;
      }
    });
    Object.defineProperty(exports, "formatTime", {
      enumerable: true,
      get: function() {
        return _formatTime.default;
      }
    });
    Object.defineProperty(exports, "globsToMatcher", {
      enumerable: true,
      get: function() {
        return _globsToMatcher.default;
      }
    });
    Object.defineProperty(exports, "installCommonGlobals", {
      enumerable: true,
      get: function() {
        return _installCommonGlobals.default;
      }
    });
    Object.defineProperty(exports, "interopRequireDefault", {
      enumerable: true,
      get: function() {
        return _interopRequireDefault.default;
      }
    });
    Object.defineProperty(exports, "isInteractive", {
      enumerable: true,
      get: function() {
        return _isInteractive.default;
      }
    });
    Object.defineProperty(exports, "isPromise", {
      enumerable: true,
      get: function() {
        return _isPromise.default;
      }
    });
    Object.defineProperty(exports, "pluralize", {
      enumerable: true,
      get: function() {
        return _pluralize.default;
      }
    });
    exports.preRunMessage = void 0;
    Object.defineProperty(exports, "replacePathSepForGlob", {
      enumerable: true,
      get: function() {
        return _replacePathSepForGlob.default;
      }
    });
    Object.defineProperty(exports, "requireOrImportModule", {
      enumerable: true,
      get: function() {
        return _requireOrImportModule.default;
      }
    });
    Object.defineProperty(exports, "setGlobal", {
      enumerable: true,
      get: function() {
        return _setGlobal.default;
      }
    });
    exports.specialChars = void 0;
    Object.defineProperty(exports, "testPathPatternToRegExp", {
      enumerable: true,
      get: function() {
        return _testPathPatternToRegExp.default;
      }
    });
    Object.defineProperty(exports, "tryRealpath", {
      enumerable: true,
      get: function() {
        return _tryRealpath.default;
      }
    });
    var preRunMessage = _interopRequireWildcard(require_preRunMessage());
    exports.preRunMessage = preRunMessage;
    var specialChars = _interopRequireWildcard(require_specialChars());
    exports.specialChars = specialChars;
    var _clearLine = _interopRequireDefault2(require_clearLine());
    var _createDirectory = _interopRequireDefault2(require_createDirectory());
    var _ErrorWithStack = _interopRequireDefault2(require_ErrorWithStack());
    var _installCommonGlobals = _interopRequireDefault2(
      require_installCommonGlobals()
    );
    var _interopRequireDefault = _interopRequireDefault2(
      require_interopRequireDefault()
    );
    var _isInteractive = _interopRequireDefault2(require_isInteractive());
    var _isPromise = _interopRequireDefault2(require_isPromise());
    var _setGlobal = _interopRequireDefault2(require_setGlobal());
    var _deepCyclicCopy = _interopRequireDefault2(require_deepCyclicCopy());
    var _convertDescriptorToString = _interopRequireDefault2(
      require_convertDescriptorToString()
    );
    var _replacePathSepForGlob = _interopRequireDefault2(
      require_replacePathSepForGlob()
    );
    var _testPathPatternToRegExp = _interopRequireDefault2(
      require_testPathPatternToRegExp()
    );
    var _globsToMatcher = _interopRequireDefault2(require_globsToMatcher());
    var _pluralize = _interopRequireDefault2(require_pluralize());
    var _formatTime = _interopRequireDefault2(require_formatTime());
    var _tryRealpath = _interopRequireDefault2(require_tryRealpath());
    var _requireOrImportModule = _interopRequireDefault2(
      require_requireOrImportModule()
    );
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
  }
});

// node_modules/expect/build/jestMatchersObject.js
var require_jestMatchersObject = __commonJS({
  "node_modules/expect/build/jestMatchersObject.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setState = exports.setMatchers = exports.getState = exports.getMatchers = exports.INTERNAL_MATCHER_FLAG = void 0;
    var _jestGetType = require_build();
    var _asymmetricMatchers = require_asymmetricMatchers();
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var JEST_MATCHERS_OBJECT = Symbol2.for("$$jest-matchers-object");
    var INTERNAL_MATCHER_FLAG = Symbol2.for("$$jest-internal-matcher");
    exports.INTERNAL_MATCHER_FLAG = INTERNAL_MATCHER_FLAG;
    if (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {
      const defaultState = {
        assertionCalls: 0,
        expectedAssertionsNumber: null,
        isExpectingAssertions: false,
        suppressedErrors: []
      };
      Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
        value: {
          matchers: /* @__PURE__ */ Object.create(null),
          state: defaultState
        }
      });
    }
    var getState = () => globalThis[JEST_MATCHERS_OBJECT].state;
    exports.getState = getState;
    var setState = (state) => {
      Object.assign(globalThis[JEST_MATCHERS_OBJECT].state, state);
    };
    exports.setState = setState;
    var getMatchers = () => globalThis[JEST_MATCHERS_OBJECT].matchers;
    exports.getMatchers = getMatchers;
    var setMatchers = (matchers, isInternal, expect) => {
      Object.keys(matchers).forEach((key) => {
        const matcher = matchers[key];
        if (typeof matcher !== "function") {
          throw new TypeError(
            `expect.extend: \`${key}\` is not a valid matcher. Must be a function, is "${(0, _jestGetType.getType)(matcher)}"`
          );
        }
        Object.defineProperty(matcher, INTERNAL_MATCHER_FLAG, {
          value: isInternal
        });
        if (!isInternal) {
          class CustomMatcher extends _asymmetricMatchers.AsymmetricMatcher {
            constructor(inverse = false, ...sample) {
              super(sample, inverse);
            }
            asymmetricMatch(other) {
              const { pass } = matcher.call(
                this.getMatcherContext(),
                other,
                ...this.sample
              );
              return this.inverse ? !pass : pass;
            }
            toString() {
              return `${this.inverse ? "not." : ""}${key}`;
            }
            getExpectedType() {
              return "any";
            }
            toAsymmetricMatcher() {
              return `${this.toString()}<${this.sample.map(String).join(", ")}>`;
            }
          }
          Object.defineProperty(expect, key, {
            configurable: true,
            enumerable: true,
            value: (...sample) => new CustomMatcher(false, ...sample),
            writable: true
          });
          Object.defineProperty(expect.not, key, {
            configurable: true,
            enumerable: true,
            value: (...sample) => new CustomMatcher(true, ...sample),
            writable: true
          });
        }
      });
      Object.assign(globalThis[JEST_MATCHERS_OBJECT].matchers, matchers);
    };
    exports.setMatchers = setMatchers;
  }
});

// node_modules/expect/build/asymmetricMatchers.js
var require_asymmetricMatchers = __commonJS({
  "node_modules/expect/build/asymmetricMatchers.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.closeTo = exports.arrayNotContaining = exports.arrayContaining = exports.anything = exports.any = exports.AsymmetricMatcher = void 0;
    exports.hasProperty = hasProperty;
    exports.stringNotMatching = exports.stringNotContaining = exports.stringMatching = exports.stringContaining = exports.objectNotContaining = exports.objectContaining = exports.notCloseTo = void 0;
    var _expectUtils = require_build4();
    var matcherUtils = _interopRequireWildcard(require_build3());
    var _jestUtil = require_build5();
    var _jestMatchersObject = require_jestMatchersObject();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var functionToString = Function.prototype.toString;
    function fnNameFor(func) {
      if (func.name) {
        return func.name;
      }
      const matches = functionToString.call(func).match(/^(?:async)?\s*function\s*\*?\s*([\w$]+)\s*\(/);
      return matches ? matches[1] : "<anonymous>";
    }
    var utils = Object.freeze({
      ...matcherUtils,
      iterableEquality: _expectUtils.iterableEquality,
      subsetEquality: _expectUtils.subsetEquality
    });
    function getPrototype(obj) {
      if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(obj);
      }
      if (obj.constructor.prototype == obj) {
        return null;
      }
      return obj.constructor.prototype;
    }
    function hasProperty(obj, property) {
      if (!obj) {
        return false;
      }
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        return true;
      }
      return hasProperty(getPrototype(obj), property);
    }
    var AsymmetricMatcher = class {
      $$typeof = Symbol2.for("jest.asymmetricMatcher");
      constructor(sample, inverse = false) {
        this.sample = sample;
        this.inverse = inverse;
      }
      getMatcherContext() {
        return {
          dontThrow: () => {
          },
          ...(0, _jestMatchersObject.getState)(),
          equals: _expectUtils.equals,
          isNot: this.inverse,
          utils
        };
      }
    };
    exports.AsymmetricMatcher = AsymmetricMatcher;
    var Any = class extends AsymmetricMatcher {
      constructor(sample) {
        if (typeof sample === "undefined") {
          throw new TypeError(
            "any() expects to be passed a constructor function. Please pass one or use anything() to match any object."
          );
        }
        super(sample);
      }
      asymmetricMatch(other) {
        if (this.sample == String) {
          return typeof other == "string" || other instanceof String;
        }
        if (this.sample == Number) {
          return typeof other == "number" || other instanceof Number;
        }
        if (this.sample == Function) {
          return typeof other == "function" || other instanceof Function;
        }
        if (this.sample == Boolean) {
          return typeof other == "boolean" || other instanceof Boolean;
        }
        if (this.sample == BigInt) {
          return typeof other == "bigint" || other instanceof BigInt;
        }
        if (this.sample == Symbol2) {
          return typeof other == "symbol" || other instanceof Symbol2;
        }
        if (this.sample == Object) {
          return typeof other == "object";
        }
        return other instanceof this.sample;
      }
      toString() {
        return "Any";
      }
      getExpectedType() {
        if (this.sample == String) {
          return "string";
        }
        if (this.sample == Number) {
          return "number";
        }
        if (this.sample == Function) {
          return "function";
        }
        if (this.sample == Object) {
          return "object";
        }
        if (this.sample == Boolean) {
          return "boolean";
        }
        return fnNameFor(this.sample);
      }
      toAsymmetricMatcher() {
        return `Any<${fnNameFor(this.sample)}>`;
      }
    };
    var Anything = class extends AsymmetricMatcher {
      asymmetricMatch(other) {
        return other != null;
      }
      toString() {
        return "Anything";
      }
      toAsymmetricMatcher() {
        return "Anything";
      }
    };
    var ArrayContaining = class extends AsymmetricMatcher {
      constructor(sample, inverse = false) {
        super(sample, inverse);
      }
      asymmetricMatch(other) {
        if (!Array.isArray(this.sample)) {
          throw new Error(
            `You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`
          );
        }
        const result = this.sample.length === 0 || Array.isArray(other) && this.sample.every(
          (item) => other.some((another) => (0, _expectUtils.equals)(item, another))
        );
        return this.inverse ? !result : result;
      }
      toString() {
        return `Array${this.inverse ? "Not" : ""}Containing`;
      }
      getExpectedType() {
        return "array";
      }
    };
    var ObjectContaining = class extends AsymmetricMatcher {
      constructor(sample, inverse = false) {
        super(sample, inverse);
      }
      asymmetricMatch(other) {
        if (typeof this.sample !== "object") {
          throw new Error(
            `You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`
          );
        }
        let result = true;
        for (const property in this.sample) {
          if (!hasProperty(other, property) || !(0, _expectUtils.equals)(this.sample[property], other[property])) {
            result = false;
            break;
          }
        }
        return this.inverse ? !result : result;
      }
      toString() {
        return `Object${this.inverse ? "Not" : ""}Containing`;
      }
      getExpectedType() {
        return "object";
      }
    };
    var StringContaining = class extends AsymmetricMatcher {
      constructor(sample, inverse = false) {
        if (!(0, _expectUtils.isA)("String", sample)) {
          throw new Error("Expected is not a string");
        }
        super(sample, inverse);
      }
      asymmetricMatch(other) {
        const result = (0, _expectUtils.isA)("String", other) && other.includes(this.sample);
        return this.inverse ? !result : result;
      }
      toString() {
        return `String${this.inverse ? "Not" : ""}Containing`;
      }
      getExpectedType() {
        return "string";
      }
    };
    var StringMatching = class extends AsymmetricMatcher {
      constructor(sample, inverse = false) {
        if (!(0, _expectUtils.isA)("String", sample) && !(0, _expectUtils.isA)("RegExp", sample)) {
          throw new Error("Expected is not a String or a RegExp");
        }
        super(new RegExp(sample), inverse);
      }
      asymmetricMatch(other) {
        const result = (0, _expectUtils.isA)("String", other) && this.sample.test(other);
        return this.inverse ? !result : result;
      }
      toString() {
        return `String${this.inverse ? "Not" : ""}Matching`;
      }
      getExpectedType() {
        return "string";
      }
    };
    var CloseTo = class extends AsymmetricMatcher {
      precision;
      constructor(sample, precision = 2, inverse = false) {
        if (!(0, _expectUtils.isA)("Number", sample)) {
          throw new Error("Expected is not a Number");
        }
        if (!(0, _expectUtils.isA)("Number", precision)) {
          throw new Error("Precision is not a Number");
        }
        super(sample);
        this.inverse = inverse;
        this.precision = precision;
      }
      asymmetricMatch(other) {
        if (!(0, _expectUtils.isA)("Number", other)) {
          return false;
        }
        let result = false;
        if (other === Infinity && this.sample === Infinity) {
          result = true;
        } else if (other === -Infinity && this.sample === -Infinity) {
          result = true;
        } else {
          result = Math.abs(this.sample - other) < Math.pow(10, -this.precision) / 2;
        }
        return this.inverse ? !result : result;
      }
      toString() {
        return `Number${this.inverse ? "Not" : ""}CloseTo`;
      }
      getExpectedType() {
        return "number";
      }
      toAsymmetricMatcher() {
        return [
          this.toString(),
          this.sample,
          `(${(0, _jestUtil.pluralize)("digit", this.precision)})`
        ].join(" ");
      }
    };
    var any = (expectedObject) => new Any(expectedObject);
    exports.any = any;
    var anything = () => new Anything();
    exports.anything = anything;
    var arrayContaining = (sample) => new ArrayContaining(sample);
    exports.arrayContaining = arrayContaining;
    var arrayNotContaining = (sample) => new ArrayContaining(sample, true);
    exports.arrayNotContaining = arrayNotContaining;
    var objectContaining = (sample) => new ObjectContaining(sample);
    exports.objectContaining = objectContaining;
    var objectNotContaining = (sample) => new ObjectContaining(sample, true);
    exports.objectNotContaining = objectNotContaining;
    var stringContaining = (expected) => new StringContaining(expected);
    exports.stringContaining = stringContaining;
    var stringNotContaining = (expected) => new StringContaining(expected, true);
    exports.stringNotContaining = stringNotContaining;
    var stringMatching = (expected) => new StringMatching(expected);
    exports.stringMatching = stringMatching;
    var stringNotMatching = (expected) => new StringMatching(expected, true);
    exports.stringNotMatching = stringNotMatching;
    var closeTo = (expected, precision) => new CloseTo(expected, precision);
    exports.closeTo = closeTo;
    var notCloseTo = (expected, precision) => new CloseTo(expected, precision, true);
    exports.notCloseTo = notCloseTo;
  }
});

// node_modules/expect/build/extractExpectedAssertionsErrors.js
var require_extractExpectedAssertionsErrors = __commonJS({
  "node_modules/expect/build/extractExpectedAssertionsErrors.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _jestMatcherUtils = require_build3();
    var _jestMatchersObject = require_jestMatchersObject();
    var resetAssertionsLocalState = () => {
      (0, _jestMatchersObject.setState)({
        assertionCalls: 0,
        expectedAssertionsNumber: null,
        isExpectingAssertions: false
      });
    };
    var extractExpectedAssertionsErrors = () => {
      const result = [];
      const {
        assertionCalls,
        expectedAssertionsNumber,
        expectedAssertionsNumberError,
        isExpectingAssertions,
        isExpectingAssertionsError
      } = (0, _jestMatchersObject.getState)();
      resetAssertionsLocalState();
      if (typeof expectedAssertionsNumber === "number" && assertionCalls !== expectedAssertionsNumber) {
        const numOfAssertionsExpected = (0, _jestMatcherUtils.EXPECTED_COLOR)(
          (0, _jestMatcherUtils.pluralize)("assertion", expectedAssertionsNumber)
        );
        expectedAssertionsNumberError.message = `${(0, _jestMatcherUtils.matcherHint)(
          ".assertions",
          "",
          expectedAssertionsNumber.toString(),
          {
            isDirectExpectCall: true
          }
        )}

Expected ${numOfAssertionsExpected} to be called but received ${(0, _jestMatcherUtils.RECEIVED_COLOR)(
          (0, _jestMatcherUtils.pluralize)("assertion call", assertionCalls || 0)
        )}.`;
        result.push({
          actual: assertionCalls.toString(),
          error: expectedAssertionsNumberError,
          expected: expectedAssertionsNumber.toString()
        });
      }
      if (isExpectingAssertions && assertionCalls === 0) {
        const expected = (0, _jestMatcherUtils.EXPECTED_COLOR)(
          "at least one assertion"
        );
        const received = (0, _jestMatcherUtils.RECEIVED_COLOR)("received none");
        isExpectingAssertionsError.message = `${(0, _jestMatcherUtils.matcherHint)(
          ".hasAssertions",
          "",
          "",
          {
            isDirectExpectCall: true
          }
        )}

Expected ${expected} to be called but ${received}.`;
        result.push({
          actual: "none",
          error: isExpectingAssertionsError,
          expected: "at least one"
        });
      }
      return result;
    };
    var _default = extractExpectedAssertionsErrors;
    exports.default = _default;
  }
});

// node_modules/expect/build/print.js
var require_print = __commonJS({
  "node_modules/expect/build/print.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printReceivedStringContainExpectedSubstring = exports.printReceivedStringContainExpectedResult = exports.printReceivedConstructorNameNot = exports.printReceivedConstructorName = exports.printReceivedArrayContainExpectedItem = exports.printExpectedConstructorNameNot = exports.printExpectedConstructorName = exports.printCloseTo = void 0;
    var _jestMatcherUtils = require_build3();
    var printSubstring = (val) => val.replace(/"|\\/g, "\\$&");
    var printReceivedStringContainExpectedSubstring = (received, start, length) => (0, _jestMatcherUtils.RECEIVED_COLOR)(
      `"${printSubstring(received.slice(0, start))}${(0, _jestMatcherUtils.INVERTED_COLOR)(
        printSubstring(received.slice(start, start + length))
      )}${printSubstring(received.slice(start + length))}"`
    );
    exports.printReceivedStringContainExpectedSubstring = printReceivedStringContainExpectedSubstring;
    var printReceivedStringContainExpectedResult = (received, result) => result === null ? (0, _jestMatcherUtils.printReceived)(received) : printReceivedStringContainExpectedSubstring(
      received,
      result.index,
      result[0].length
    );
    exports.printReceivedStringContainExpectedResult = printReceivedStringContainExpectedResult;
    var printReceivedArrayContainExpectedItem = (received, index) => (0, _jestMatcherUtils.RECEIVED_COLOR)(
      `[${received.map((item, i) => {
        const stringified = (0, _jestMatcherUtils.stringify)(item);
        return i === index ? (0, _jestMatcherUtils.INVERTED_COLOR)(stringified) : stringified;
      }).join(", ")}]`
    );
    exports.printReceivedArrayContainExpectedItem = printReceivedArrayContainExpectedItem;
    var printCloseTo = (receivedDiff, expectedDiff, precision, isNot) => {
      const receivedDiffString = (0, _jestMatcherUtils.stringify)(receivedDiff);
      const expectedDiffString = receivedDiffString.includes("e") ? expectedDiff.toExponential(0) : 0 <= precision && precision < 20 ? expectedDiff.toFixed(precision + 1) : (0, _jestMatcherUtils.stringify)(expectedDiff);
      return `Expected precision:  ${isNot ? "    " : ""}  ${(0, _jestMatcherUtils.stringify)(precision)}
Expected difference: ${isNot ? "not " : ""}< ${(0, _jestMatcherUtils.EXPECTED_COLOR)(expectedDiffString)}
Received difference: ${isNot ? "    " : ""}  ${(0, _jestMatcherUtils.RECEIVED_COLOR)(receivedDiffString)}`;
    };
    exports.printCloseTo = printCloseTo;
    var printExpectedConstructorName = (label, expected) => `${printConstructorName(label, expected, false, true)}
`;
    exports.printExpectedConstructorName = printExpectedConstructorName;
    var printExpectedConstructorNameNot = (label, expected) => `${printConstructorName(label, expected, true, true)}
`;
    exports.printExpectedConstructorNameNot = printExpectedConstructorNameNot;
    var printReceivedConstructorName = (label, received) => `${printConstructorName(label, received, false, false)}
`;
    exports.printReceivedConstructorName = printReceivedConstructorName;
    var printReceivedConstructorNameNot = (label, received, expected) => typeof expected.name === "string" && expected.name.length !== 0 && typeof received.name === "string" && received.name.length !== 0 ? `${printConstructorName(label, received, true, false)} ${Object.getPrototypeOf(received) === expected ? "extends" : "extends \u2026 extends"} ${(0, _jestMatcherUtils.EXPECTED_COLOR)(expected.name)}
` : `${printConstructorName(label, received, false, false)}
`;
    exports.printReceivedConstructorNameNot = printReceivedConstructorNameNot;
    var printConstructorName = (label, constructor, isNot, isExpected) => typeof constructor.name !== "string" ? `${label} name is not a string` : constructor.name.length === 0 ? `${label} name is an empty string` : `${label}: ${!isNot ? "" : isExpected ? "not " : "    "}${isExpected ? (0, _jestMatcherUtils.EXPECTED_COLOR)(constructor.name) : (0, _jestMatcherUtils.RECEIVED_COLOR)(constructor.name)}`;
  }
});

// node_modules/expect/build/matchers.js
var require_matchers = __commonJS({
  "node_modules/expect/build/matchers.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _expectUtils = require_build4();
    var _jestGetType = require_build();
    var _jestMatcherUtils = require_build3();
    var _print = require_print();
    var EXPECTED_LABEL = "Expected";
    var RECEIVED_LABEL = "Received";
    var EXPECTED_VALUE_LABEL = "Expected value";
    var RECEIVED_VALUE_LABEL = "Received value";
    var isExpand = (expand) => expand !== false;
    var toStrictEqualTesters = [
      _expectUtils.iterableEquality,
      _expectUtils.typeEquality,
      _expectUtils.sparseArrayEquality,
      _expectUtils.arrayBufferEquality
    ];
    var matchers = {
      toBe(received, expected) {
        const matcherName = "toBe";
        const options = {
          comment: "Object.is equality",
          isNot: this.isNot,
          promise: this.promise
        };
        const pass = Object.is(received, expected);
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}` : () => {
          const expectedType = (0, _jestGetType.getType)(expected);
          let deepEqualityName = null;
          if (expectedType !== "map" && expectedType !== "set") {
            if ((0, _expectUtils.equals)(
              received,
              expected,
              toStrictEqualTesters,
              true
            )) {
              deepEqualityName = "toStrictEqual";
            } else if ((0, _expectUtils.equals)(received, expected, [
              _expectUtils.iterableEquality
            ])) {
              deepEqualityName = "toEqual";
            }
          }
          return (0, _jestMatcherUtils.matcherHint)(
            matcherName,
            void 0,
            void 0,
            options
          ) + "\n\n" + (deepEqualityName !== null ? `${(0, _jestMatcherUtils.DIM_COLOR)(
            `If it should pass with deep equality, replace "${matcherName}" with "${deepEqualityName}"`
          )}

` : "") + (0, _jestMatcherUtils.printDiffOrStringify)(
            expected,
            received,
            EXPECTED_LABEL,
            RECEIVED_LABEL,
            isExpand(this.expand)
          );
        };
        return {
          actual: received,
          expected,
          message,
          name: matcherName,
          pass
        };
      },
      toBeCloseTo(received, expected, precision = 2) {
        const matcherName = "toBeCloseTo";
        const secondArgument = arguments.length === 3 ? "precision" : void 0;
        const isNot = this.isNot;
        const options = {
          isNot,
          promise: this.promise,
          secondArgument,
          secondArgumentColor: (arg) => arg
        };
        if (typeof expected !== "number") {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                "expected"
              )} value must be a number`,
              (0, _jestMatcherUtils.printWithType)(
                "Expected",
                expected,
                _jestMatcherUtils.printExpected
              )
            )
          );
        }
        if (typeof received !== "number") {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must be a number`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        let pass = false;
        let expectedDiff = 0;
        let receivedDiff = 0;
        if (received === Infinity && expected === Infinity) {
          pass = true;
        } else if (received === -Infinity && expected === -Infinity) {
          pass = true;
        } else {
          expectedDiff = Math.pow(10, -precision) / 2;
          receivedDiff = Math.abs(expected - received);
          pass = receivedDiff < expectedDiff;
        }
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + (receivedDiff === 0 ? "" : `Received:     ${(0, _jestMatcherUtils.printReceived)(
          received
        )}

${(0, _print.printCloseTo)(
          receivedDiff,
          expectedDiff,
          precision,
          isNot
        )}`) : () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
Received: ${(0, _jestMatcherUtils.printReceived)(received)}

` + (0, _print.printCloseTo)(
          receivedDiff,
          expectedDiff,
          precision,
          isNot
        );
        return {
          message,
          pass
        };
      },
      toBeDefined(received, expected) {
        const matcherName = "toBeDefined";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
        const pass = received !== void 0;
        const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeFalsy(received, expected) {
        const matcherName = "toBeFalsy";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
        const pass = !received;
        const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeGreaterThan(received, expected) {
        const matcherName = "toBeGreaterThan";
        const isNot = this.isNot;
        const options = {
          isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNumbers)(
          received,
          expected,
          matcherName,
          options
        );
        const pass = received > expected;
        const message = () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected:${isNot ? " not" : ""} > ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
Received:${isNot ? "    " : ""}   ${(0, _jestMatcherUtils.printReceived)(
          received
        )}`;
        return {
          message,
          pass
        };
      },
      toBeGreaterThanOrEqual(received, expected) {
        const matcherName = "toBeGreaterThanOrEqual";
        const isNot = this.isNot;
        const options = {
          isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNumbers)(
          received,
          expected,
          matcherName,
          options
        );
        const pass = received >= expected;
        const message = () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected:${isNot ? " not" : ""} >= ${(0, _jestMatcherUtils.printExpected)(expected)}
Received:${isNot ? "    " : ""}    ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeInstanceOf(received, expected) {
        const matcherName = "toBeInstanceOf";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        if (typeof expected !== "function") {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                "expected"
              )} value must be a function`,
              (0, _jestMatcherUtils.printWithType)(
                "Expected",
                expected,
                _jestMatcherUtils.printExpected
              )
            )
          );
        }
        const pass = received instanceof expected;
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + "\n\n" + (0, _print.printExpectedConstructorNameNot)(
          "Expected constructor",
          expected
        ) + (typeof received.constructor === "function" && received.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)(
          "Received constructor",
          received.constructor,
          expected
        ) : "") : () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + "\n\n" + (0, _print.printExpectedConstructorName)(
          "Expected constructor",
          expected
        ) + ((0, _jestGetType.isPrimitive)(received) || Object.getPrototypeOf(received) === null ? `
Received value has no prototype
Received value: ${(0, _jestMatcherUtils.printReceived)(received)}` : typeof received.constructor !== "function" ? `
Received value: ${(0, _jestMatcherUtils.printReceived)(
          received
        )}` : (0, _print.printReceivedConstructorName)(
          "Received constructor",
          received.constructor
        ));
        return {
          message,
          pass
        };
      },
      toBeLessThan(received, expected) {
        const matcherName = "toBeLessThan";
        const isNot = this.isNot;
        const options = {
          isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNumbers)(
          received,
          expected,
          matcherName,
          options
        );
        const pass = received < expected;
        const message = () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected:${isNot ? " not" : ""} < ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
Received:${isNot ? "    " : ""}   ${(0, _jestMatcherUtils.printReceived)(
          received
        )}`;
        return {
          message,
          pass
        };
      },
      toBeLessThanOrEqual(received, expected) {
        const matcherName = "toBeLessThanOrEqual";
        const isNot = this.isNot;
        const options = {
          isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNumbers)(
          received,
          expected,
          matcherName,
          options
        );
        const pass = received <= expected;
        const message = () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected:${isNot ? " not" : ""} <= ${(0, _jestMatcherUtils.printExpected)(expected)}
Received:${isNot ? "    " : ""}    ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeNaN(received, expected) {
        const matcherName = "toBeNaN";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
        const pass = Number.isNaN(received);
        const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeNull(received, expected) {
        const matcherName = "toBeNull";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
        const pass = received === null;
        const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeTruthy(received, expected) {
        const matcherName = "toBeTruthy";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
        const pass = !!received;
        const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toBeUndefined(received, expected) {
        const matcherName = "toBeUndefined";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
        const pass = received === void 0;
        const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`;
        return {
          message,
          pass
        };
      },
      toContain(received, expected) {
        const matcherName = "toContain";
        const isNot = this.isNot;
        const options = {
          comment: "indexOf",
          isNot,
          promise: this.promise
        };
        if (received == null) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must not be null nor undefined`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        if (typeof received === "string") {
          const wrongTypeErrorMessage = `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
            "expected"
          )} value must be a string if ${(0, _jestMatcherUtils.RECEIVED_COLOR)(
            "received"
          )} value is a string`;
          if (typeof expected !== "string") {
            throw new Error(
              (0, _jestMatcherUtils.matcherErrorMessage)(
                (0, _jestMatcherUtils.matcherHint)(
                  matcherName,
                  received,
                  String(expected),
                  options
                ),
                wrongTypeErrorMessage,
                (0, _jestMatcherUtils.printWithType)(
                  "Expected",
                  expected,
                  _jestMatcherUtils.printExpected
                ) + "\n" + (0, _jestMatcherUtils.printWithType)(
                  "Received",
                  received,
                  _jestMatcherUtils.printReceived
                )
              )
            );
          }
          const index2 = received.indexOf(String(expected));
          const pass2 = index2 !== -1;
          const message2 = () => {
            const labelExpected = `Expected ${typeof expected === "string" ? "substring" : "value"}`;
            const labelReceived = "Received string";
            const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(
              labelExpected,
              labelReceived
            );
            return (0, _jestMatcherUtils.matcherHint)(
              matcherName,
              void 0,
              void 0,
              options
            ) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${isNot ? "    " : ""}${isNot ? (0, _print.printReceivedStringContainExpectedSubstring)(
              received,
              index2,
              String(expected).length
            ) : (0, _jestMatcherUtils.printReceived)(received)}`;
          };
          return {
            message: message2,
            pass: pass2
          };
        }
        const indexable = Array.from(received);
        const index = indexable.indexOf(expected);
        const pass = index !== -1;
        const message = () => {
          const labelExpected = "Expected value";
          const labelReceived = `Received ${(0, _jestGetType.getType)(received)}`;
          const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(
            labelExpected,
            labelReceived
          );
          return (0, _jestMatcherUtils.matcherHint)(
            matcherName,
            void 0,
            void 0,
            options
          ) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${isNot ? "    " : ""}${isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received)}` + (!isNot && indexable.findIndex(
            (item) => (0, _expectUtils.equals)(item, expected, [
              _expectUtils.iterableEquality
            ])
          ) !== -1 ? `

${_jestMatcherUtils.SUGGEST_TO_CONTAIN_EQUAL}` : "");
        };
        return {
          message,
          pass
        };
      },
      toContainEqual(received, expected) {
        const matcherName = "toContainEqual";
        const isNot = this.isNot;
        const options = {
          comment: "deep equality",
          isNot,
          promise: this.promise
        };
        if (received == null) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must not be null nor undefined`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        const index = Array.from(received).findIndex(
          (item) => (0, _expectUtils.equals)(item, expected, [_expectUtils.iterableEquality])
        );
        const pass = index !== -1;
        const message = () => {
          const labelExpected = "Expected value";
          const labelReceived = `Received ${(0, _jestGetType.getType)(received)}`;
          const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(
            labelExpected,
            labelReceived
          );
          return (0, _jestMatcherUtils.matcherHint)(
            matcherName,
            void 0,
            void 0,
            options
          ) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${isNot ? "    " : ""}${isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received)}`;
        };
        return {
          message,
          pass
        };
      },
      toEqual(received, expected) {
        const matcherName = "toEqual";
        const options = {
          comment: "deep equality",
          isNot: this.isNot,
          promise: this.promise
        };
        const pass = (0, _expectUtils.equals)(received, expected, [
          _expectUtils.iterableEquality
        ]);
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? `Received:     ${(0, _jestMatcherUtils.printReceived)(received)}` : "") : () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + "\n\n" + (0, _jestMatcherUtils.printDiffOrStringify)(
          expected,
          received,
          EXPECTED_LABEL,
          RECEIVED_LABEL,
          isExpand(this.expand)
        );
        return {
          actual: received,
          expected,
          message,
          name: matcherName,
          pass
        };
      },
      toHaveLength(received, expected) {
        const matcherName = "toHaveLength";
        const isNot = this.isNot;
        const options = {
          isNot,
          promise: this.promise
        };
        if (typeof received?.length !== "number") {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must have a length property whose value must be a number`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(
          expected,
          matcherName,
          options
        );
        const pass = received.length === expected;
        const message = () => {
          const labelExpected = "Expected length";
          const labelReceivedLength = "Received length";
          const labelReceivedValue = `Received ${(0, _jestGetType.getType)(
            received
          )}`;
          const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(
            labelExpected,
            labelReceivedLength,
            labelReceivedValue
          );
          return (0, _jestMatcherUtils.matcherHint)(
            matcherName,
            void 0,
            void 0,
            options
          ) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
` + (isNot ? "" : `${printLabel(labelReceivedLength)}${(0, _jestMatcherUtils.printReceived)(received.length)}
`) + `${printLabel(labelReceivedValue)}${isNot ? "    " : ""}${(0, _jestMatcherUtils.printReceived)(received)}`;
        };
        return {
          message,
          pass
        };
      },
      toHaveProperty(received, expectedPath, expectedValue) {
        const matcherName = "toHaveProperty";
        const expectedArgument = "path";
        const hasValue = arguments.length === 3;
        const options = {
          isNot: this.isNot,
          promise: this.promise,
          secondArgument: hasValue ? "value" : ""
        };
        if (received === null || received === void 0) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                expectedArgument,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must not be null nor undefined`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        const expectedPathType = (0, _jestGetType.getType)(expectedPath);
        if (expectedPathType !== "string" && expectedPathType !== "array") {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                expectedArgument,
                options
              ),
              `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                "expected"
              )} path must be a string or array`,
              (0, _jestMatcherUtils.printWithType)(
                "Expected",
                expectedPath,
                _jestMatcherUtils.printExpected
              )
            )
          );
        }
        const expectedPathLength = typeof expectedPath === "string" ? (0, _expectUtils.pathAsArray)(expectedPath).length : expectedPath.length;
        if (expectedPathType === "array" && expectedPathLength === 0) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                expectedArgument,
                options
              ),
              `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                "expected"
              )} path must not be an empty array`,
              (0, _jestMatcherUtils.printWithType)(
                "Expected",
                expectedPath,
                _jestMatcherUtils.printExpected
              )
            )
          );
        }
        const result = (0, _expectUtils.getPath)(received, expectedPath);
        const { lastTraversedObject, endPropIsDefined, hasEndProp, value } = result;
        const receivedPath = result.traversedPath;
        const hasCompletePath = receivedPath.length === expectedPathLength;
        const receivedValue = hasCompletePath ? result.value : lastTraversedObject;
        const pass = hasValue && endPropIsDefined ? (0, _expectUtils.equals)(value, expectedValue, [
          _expectUtils.iterableEquality
        ]) : Boolean(hasEndProp);
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          expectedArgument,
          options
        ) + "\n\n" + (hasValue ? `Expected path: ${(0, _jestMatcherUtils.printExpected)(
          expectedPath
        )}

Expected value: not ${(0, _jestMatcherUtils.printExpected)(
          expectedValue
        )}${(0, _jestMatcherUtils.stringify)(expectedValue) !== (0, _jestMatcherUtils.stringify)(receivedValue) ? `
Received value:     ${(0, _jestMatcherUtils.printReceived)(receivedValue)}` : ""}` : `Expected path: not ${(0, _jestMatcherUtils.printExpected)(
          expectedPath
        )}

Received value: ${(0, _jestMatcherUtils.printReceived)(
          receivedValue
        )}`) : () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          expectedArgument,
          options
        ) + `

Expected path: ${(0, _jestMatcherUtils.printExpected)(
          expectedPath
        )}
` + (hasCompletePath ? `
${(0, _jestMatcherUtils.printDiffOrStringify)(
          expectedValue,
          receivedValue,
          EXPECTED_VALUE_LABEL,
          RECEIVED_VALUE_LABEL,
          isExpand(this.expand)
        )}` : `Received path: ${(0, _jestMatcherUtils.printReceived)(
          expectedPathType === "array" || receivedPath.length === 0 ? receivedPath : receivedPath.join(".")
        )}

${hasValue ? `Expected value: ${(0, _jestMatcherUtils.printExpected)(
          expectedValue
        )}
` : ""}Received value: ${(0, _jestMatcherUtils.printReceived)(
          receivedValue
        )}`);
        return {
          message,
          pass
        };
      },
      toMatch(received, expected) {
        const matcherName = "toMatch";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        if (typeof received !== "string") {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must be a string`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        if (!(typeof expected === "string") && !(expected && typeof expected.test === "function")) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                "expected"
              )} value must be a string or regular expression`,
              (0, _jestMatcherUtils.printWithType)(
                "Expected",
                expected,
                _jestMatcherUtils.printExpected
              )
            )
          );
        }
        const pass = typeof expected === "string" ? received.includes(expected) : new RegExp(expected).test(received);
        const message = pass ? () => typeof expected === "string" ? (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected substring: not ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
Received string:        ${(0, _print.printReceivedStringContainExpectedSubstring)(
          received,
          received.indexOf(expected),
          expected.length
        )}` : (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected pattern: not ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
Received string:      ${(0, _print.printReceivedStringContainExpectedResult)(
          received,
          typeof expected.exec === "function" ? expected.exec(received) : null
        )}` : () => {
          const labelExpected = `Expected ${typeof expected === "string" ? "substring" : "pattern"}`;
          const labelReceived = "Received string";
          const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(
            labelExpected,
            labelReceived
          );
          return (0, _jestMatcherUtils.matcherHint)(
            matcherName,
            void 0,
            void 0,
            options
          ) + `

${printLabel(labelExpected)}${(0, _jestMatcherUtils.printExpected)(
            expected
          )}
${printLabel(labelReceived)}${(0, _jestMatcherUtils.printReceived)(
            received
          )}`;
        };
        return {
          message,
          pass
        };
      },
      toMatchObject(received, expected) {
        const matcherName = "toMatchObject";
        const options = {
          isNot: this.isNot,
          promise: this.promise
        };
        if (typeof received !== "object" || received === null) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                "received"
              )} value must be a non-null object`,
              (0, _jestMatcherUtils.printWithType)(
                "Received",
                received,
                _jestMatcherUtils.printReceived
              )
            )
          );
        }
        if (typeof expected !== "object" || expected === null) {
          throw new Error(
            (0, _jestMatcherUtils.matcherErrorMessage)(
              (0, _jestMatcherUtils.matcherHint)(
                matcherName,
                void 0,
                void 0,
                options
              ),
              `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                "expected"
              )} value must be a non-null object`,
              (0, _jestMatcherUtils.printWithType)(
                "Expected",
                expected,
                _jestMatcherUtils.printExpected
              )
            )
          );
        }
        const pass = (0, _expectUtils.equals)(received, expected, [
          _expectUtils.iterableEquality,
          _expectUtils.subsetEquality
        ]);
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}` + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? `
Received:     ${(0, _jestMatcherUtils.printReceived)(
          received
        )}` : "") : () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + "\n\n" + (0, _jestMatcherUtils.printDiffOrStringify)(
          expected,
          (0, _expectUtils.getObjectSubset)(received, expected),
          EXPECTED_LABEL,
          RECEIVED_LABEL,
          isExpand(this.expand)
        );
        return {
          message,
          pass
        };
      },
      toStrictEqual(received, expected) {
        const matcherName = "toStrictEqual";
        const options = {
          comment: "deep equality",
          isNot: this.isNot,
          promise: this.promise
        };
        const pass = (0, _expectUtils.equals)(
          received,
          expected,
          toStrictEqualTesters,
          true
        );
        const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? `Received:     ${(0, _jestMatcherUtils.printReceived)(received)}` : "") : () => (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          void 0,
          void 0,
          options
        ) + "\n\n" + (0, _jestMatcherUtils.printDiffOrStringify)(
          expected,
          received,
          EXPECTED_LABEL,
          RECEIVED_LABEL,
          isExpand(this.expand)
        );
        return {
          actual: received,
          expected,
          message,
          name: matcherName,
          pass
        };
      }
    };
    var _default = matchers;
    exports.default = _default;
  }
});

// node_modules/expect/build/spyMatchers.js
var require_spyMatchers = __commonJS({
  "node_modules/expect/build/spyMatchers.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _expectUtils = require_build4();
    var _jestGetType = require_build();
    var _jestMatcherUtils = require_build3();
    var isExpand = (expand) => expand !== false;
    var PRINT_LIMIT = 3;
    var NO_ARGUMENTS = "called with 0 arguments";
    var printExpectedArgs = (expected) => expected.length === 0 ? NO_ARGUMENTS : expected.map((arg) => (0, _jestMatcherUtils.printExpected)(arg)).join(", ");
    var printReceivedArgs = (received, expected) => received.length === 0 ? NO_ARGUMENTS : received.map(
      (arg, i) => Array.isArray(expected) && i < expected.length && isEqualValue(expected[i], arg) ? printCommon(arg) : (0, _jestMatcherUtils.printReceived)(arg)
    ).join(", ");
    var printCommon = (val) => (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));
    var isEqualValue = (expected, received) => (0, _expectUtils.equals)(expected, received, [_expectUtils.iterableEquality]);
    var isEqualCall = (expected, received) => received.length === expected.length && isEqualValue(expected, received);
    var isEqualReturn = (expected, result) => result.type === "return" && isEqualValue(expected, result.value);
    var countReturns = (results) => results.reduce((n, result) => result.type === "return" ? n + 1 : n, 0);
    var printNumberOfReturns = (countReturns2, countCalls) => `
Number of returns: ${(0, _jestMatcherUtils.printReceived)(countReturns2)}${countCalls !== countReturns2 ? `
Number of calls:   ${(0, _jestMatcherUtils.printReceived)(
      countCalls
    )}` : ""}`;
    var getRightAlignedPrinter = (label) => {
      const index = label.indexOf(":");
      const suffix = label.slice(index);
      return (string, isExpectedCall) => (isExpectedCall ? `->${" ".repeat(Math.max(0, index - 2 - string.length))}` : " ".repeat(Math.max(index - string.length))) + string + suffix;
    };
    var printReceivedCallsNegative = (expected, indexedCalls, isOnlyCall, iExpectedCall) => {
      if (indexedCalls.length === 0) {
        return "";
      }
      const label = "Received:     ";
      if (isOnlyCall) {
        return `${label + printReceivedArgs(indexedCalls[0], expected)}
`;
      }
      const printAligned = getRightAlignedPrinter(label);
      return `Received
${indexedCalls.reduce(
        (printed, [i, args]) => `${printed + printAligned(String(i + 1), i === iExpectedCall) + printReceivedArgs(args, expected)}
`,
        ""
      )}`;
    };
    var printExpectedReceivedCallsPositive = (expected, indexedCalls, expand, isOnlyCall, iExpectedCall) => {
      const expectedLine = `Expected: ${printExpectedArgs(expected)}
`;
      if (indexedCalls.length === 0) {
        return expectedLine;
      }
      const label = "Received: ";
      if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === void 0)) {
        const received = indexedCalls[0][1];
        if (isLineDiffableCall(expected, received)) {
          const lines = [
            (0, _jestMatcherUtils.EXPECTED_COLOR)("- Expected"),
            (0, _jestMatcherUtils.RECEIVED_COLOR)("+ Received"),
            ""
          ];
          const length = Math.max(expected.length, received.length);
          for (let i = 0; i < length; i += 1) {
            if (i < expected.length && i < received.length) {
              if (isEqualValue(expected[i], received[i])) {
                lines.push(`  ${printCommon(received[i])},`);
                continue;
              }
              if (isLineDiffableArg(expected[i], received[i])) {
                const difference = (0, _jestMatcherUtils.diff)(
                  expected[i],
                  received[i],
                  {
                    expand
                  }
                );
                if (typeof difference === "string" && difference.includes("- Expected") && difference.includes("+ Received")) {
                  lines.push(`${difference.split("\n").slice(3).join("\n")},`);
                  continue;
                }
              }
            }
            if (i < expected.length) {
              lines.push(
                `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
                  `- ${(0, _jestMatcherUtils.stringify)(expected[i])}`
                )},`
              );
            }
            if (i < received.length) {
              lines.push(
                `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                  `+ ${(0, _jestMatcherUtils.stringify)(received[i])}`
                )},`
              );
            }
          }
          return `${lines.join("\n")}
`;
        }
        return `${expectedLine + label + printReceivedArgs(received, expected)}
`;
      }
      const printAligned = getRightAlignedPrinter(label);
      return expectedLine + "Received\n" + indexedCalls.reduce((printed, [i, received]) => {
        const aligned = printAligned(String(i + 1), i === iExpectedCall);
        return `${printed + ((i === iExpectedCall || iExpectedCall === void 0) && isLineDiffableCall(expected, received) ? aligned.replace(": ", "\n") + printDiffCall(expected, received, expand) : aligned + printReceivedArgs(received, expected))}
`;
      }, "");
    };
    var indentation = "Received".replace(/\w/g, " ");
    var printDiffCall = (expected, received, expand) => received.map((arg, i) => {
      if (i < expected.length) {
        if (isEqualValue(expected[i], arg)) {
          return `${indentation}  ${printCommon(arg)},`;
        }
        if (isLineDiffableArg(expected[i], arg)) {
          const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {
            expand
          });
          if (typeof difference === "string" && difference.includes("- Expected") && difference.includes("+ Received")) {
            return `${difference.split("\n").slice(3).map((line) => indentation + line).join("\n")},`;
          }
        }
      }
      return `${indentation + (i < expected.length ? `  ${(0, _jestMatcherUtils.printReceived)(arg)}` : (0, _jestMatcherUtils.RECEIVED_COLOR)(
        `+ ${(0, _jestMatcherUtils.stringify)(arg)}`
      ))},`;
    }).join("\n");
    var isLineDiffableCall = (expected, received) => expected.some(
      (arg, i) => i < received.length && isLineDiffableArg(arg, received[i])
    );
    var isLineDiffableArg = (expected, received) => {
      const expectedType = (0, _jestGetType.getType)(expected);
      const receivedType = (0, _jestGetType.getType)(received);
      if (expectedType !== receivedType) {
        return false;
      }
      if ((0, _jestGetType.isPrimitive)(expected)) {
        return false;
      }
      if (expectedType === "date" || expectedType === "function" || expectedType === "regexp") {
        return false;
      }
      if (expected instanceof Error && received instanceof Error) {
        return false;
      }
      if (expectedType === "object" && typeof expected.asymmetricMatch === "function") {
        return false;
      }
      if (receivedType === "object" && typeof received.asymmetricMatch === "function") {
        return false;
      }
      return true;
    };
    var printResult = (result, expected) => result.type === "throw" ? "function call threw an error" : result.type === "incomplete" ? "function call has not returned yet" : isEqualValue(expected, result.value) ? printCommon(result.value) : (0, _jestMatcherUtils.printReceived)(result.value);
    var printReceivedResults = (label, expected, indexedResults, isOnlyCall, iExpectedCall) => {
      if (indexedResults.length === 0) {
        return "";
      }
      if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === void 0)) {
        return `${label + printResult(indexedResults[0][1], expected)}
`;
      }
      const printAligned = getRightAlignedPrinter(label);
      return label.replace(":", "").trim() + "\n" + indexedResults.reduce(
        (printed, [i, result]) => `${printed + printAligned(String(i + 1), i === iExpectedCall) + printResult(result, expected)}
`,
        ""
      );
    };
    var createToBeCalledMatcher = (matcherName) => function(received, expected) {
      const expectedArgument = "";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
      ensureMockOrSpy(received, matcherName, expectedArgument, options);
      const receivedIsSpy = isSpy(received);
      const receivedName = receivedIsSpy ? "spy" : received.getMockName();
      const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;
      const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
      const pass = count > 0;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(
        0
      )}
Received number of calls: ${(0, _jestMatcherUtils.printReceived)(
        count
      )}

` + calls.reduce((lines, args, i) => {
        if (lines.length < PRINT_LIMIT) {
          lines.push(`${i + 1}: ${printReceivedArgs(args)}`);
        }
        return lines;
      }, []).join("\n") : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of calls: >= ${(0, _jestMatcherUtils.printExpected)(
        1
      )}
Received number of calls:    ${(0, _jestMatcherUtils.printReceived)(
        count
      )}`;
      return {
        message,
        pass
      };
    };
    var createToReturnMatcher = (matcherName) => function(received, expected) {
      const expectedArgument = "";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
      ensureMock(received, matcherName, expectedArgument, options);
      const receivedName = received.getMockName();
      const count = received.mock.results.reduce(
        (n, result) => result.type === "return" ? n + 1 : n,
        0
      );
      const pass = count > 0;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(
        0
      )}
Received number of returns: ${(0, _jestMatcherUtils.printReceived)(
        count
      )}

` + received.mock.results.reduce((lines, result, i) => {
        if (result.type === "return" && lines.length < PRINT_LIMIT) {
          lines.push(
            `${i + 1}: ${(0, _jestMatcherUtils.printReceived)(
              result.value
            )}`
          );
        }
        return lines;
      }, []).join("\n") + (received.mock.calls.length !== count ? `

Received number of calls:   ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : "") : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of returns: >= ${(0, _jestMatcherUtils.printExpected)(1)}
Received number of returns:    ${(0, _jestMatcherUtils.printReceived)(count)}` + (received.mock.calls.length !== count ? `
Received number of calls:      ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : "");
      return {
        message,
        pass
      };
    };
    var createToBeCalledTimesMatcher = (matcherName) => function(received, expected) {
      const expectedArgument = "expected";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(
        expected,
        matcherName,
        options
      );
      ensureMockOrSpy(received, matcherName, expectedArgument, options);
      const receivedIsSpy = isSpy(received);
      const receivedName = receivedIsSpy ? "spy" : received.getMockName();
      const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;
      const pass = count === expected;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of calls: not ${(0, _jestMatcherUtils.printExpected)(
        expected
      )}` : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(
        expected
      )}
Received number of calls: ${(0, _jestMatcherUtils.printReceived)(
        count
      )}`;
      return {
        message,
        pass
      };
    };
    var createToReturnTimesMatcher = (matcherName) => function(received, expected) {
      const expectedArgument = "expected";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(
        expected,
        matcherName,
        options
      );
      ensureMock(received, matcherName, expectedArgument, options);
      const receivedName = received.getMockName();
      const count = received.mock.results.reduce(
        (n, result) => result.type === "return" ? n + 1 : n,
        0
      );
      const pass = count === expected;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of returns: not ${(0, _jestMatcherUtils.printExpected)(expected)}` + (received.mock.calls.length !== count ? `

Received number of calls:       ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : "") : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        receivedName,
        expectedArgument,
        options
      ) + `

Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(
        expected
      )}
Received number of returns: ${(0, _jestMatcherUtils.printReceived)(
        count
      )}` + (received.mock.calls.length !== count ? `
Received number of calls:   ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : "");
      return {
        message,
        pass
      };
    };
    var createToBeCalledWithMatcher = (matcherName) => function(received, ...expected) {
      const expectedArgument = "...expected";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      ensureMockOrSpy(received, matcherName, expectedArgument, options);
      const receivedIsSpy = isSpy(received);
      const receivedName = receivedIsSpy ? "spy" : received.getMockName();
      const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
      const pass = calls.some((call) => isEqualCall(expected, call));
      const message = pass ? () => {
        const indexedCalls = [];
        let i = 0;
        while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {
          if (isEqualCall(expected, calls[i])) {
            indexedCalls.push([i, calls[i]]);
          }
          i += 1;
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

Expected: not ${printExpectedArgs(expected)}
` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedCallsNegative(
          expected,
          indexedCalls,
          calls.length === 1
        )) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(
          calls.length
        )}`;
      } : () => {
        const indexedCalls = [];
        let i = 0;
        while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {
          indexedCalls.push([i, calls[i]]);
          i += 1;
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + "\n\n" + printExpectedReceivedCallsPositive(
          expected,
          indexedCalls,
          isExpand(this.expand),
          calls.length === 1
        ) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(
          calls.length
        )}`;
      };
      return {
        message,
        pass
      };
    };
    var createToReturnWithMatcher = (matcherName) => function(received, expected) {
      const expectedArgument = "expected";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      ensureMock(received, matcherName, expectedArgument, options);
      const receivedName = received.getMockName();
      const { calls, results } = received.mock;
      const pass = results.some((result) => isEqualReturn(expected, result));
      const message = pass ? () => {
        const indexedResults = [];
        let i = 0;
        while (i < results.length && indexedResults.length < PRINT_LIMIT) {
          if (isEqualReturn(expected, results[i])) {
            indexedResults.push([i, results[i]]);
          }
          i += 1;
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
` + (results.length === 1 && results[0].type === "return" && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedResults(
          "Received:     ",
          expected,
          indexedResults,
          results.length === 1
        )) + printNumberOfReturns(countReturns(results), calls.length);
      } : () => {
        const indexedResults = [];
        let i = 0;
        while (i < results.length && indexedResults.length < PRINT_LIMIT) {
          indexedResults.push([i, results[i]]);
          i += 1;
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
` + printReceivedResults(
          "Received: ",
          expected,
          indexedResults,
          results.length === 1
        ) + printNumberOfReturns(countReturns(results), calls.length);
      };
      return {
        message,
        pass
      };
    };
    var createLastCalledWithMatcher = (matcherName) => function(received, ...expected) {
      const expectedArgument = "...expected";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      ensureMockOrSpy(received, matcherName, expectedArgument, options);
      const receivedIsSpy = isSpy(received);
      const receivedName = receivedIsSpy ? "spy" : received.getMockName();
      const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
      const iLast = calls.length - 1;
      const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);
      const message = pass ? () => {
        const indexedCalls = [];
        if (iLast > 0) {
          indexedCalls.push([iLast - 1, calls[iLast - 1]]);
        }
        indexedCalls.push([iLast, calls[iLast]]);
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

Expected: not ${printExpectedArgs(expected)}
` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedCallsNegative(
          expected,
          indexedCalls,
          calls.length === 1,
          iLast
        )) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(
          calls.length
        )}`;
      } : () => {
        const indexedCalls = [];
        if (iLast >= 0) {
          if (iLast > 0) {
            let i = iLast - 1;
            while (i >= 0 && !isEqualCall(expected, calls[i])) {
              i -= 1;
            }
            if (i < 0) {
              i = iLast - 1;
            }
            indexedCalls.push([i, calls[i]]);
          }
          indexedCalls.push([iLast, calls[iLast]]);
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + "\n\n" + printExpectedReceivedCallsPositive(
          expected,
          indexedCalls,
          isExpand(this.expand),
          calls.length === 1,
          iLast
        ) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(
          calls.length
        )}`;
      };
      return {
        message,
        pass
      };
    };
    var createLastReturnedMatcher = (matcherName) => function(received, expected) {
      const expectedArgument = "expected";
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      ensureMock(received, matcherName, expectedArgument, options);
      const receivedName = received.getMockName();
      const { calls, results } = received.mock;
      const iLast = results.length - 1;
      const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);
      const message = pass ? () => {
        const indexedResults = [];
        if (iLast > 0) {
          indexedResults.push([iLast - 1, results[iLast - 1]]);
        }
        indexedResults.push([iLast, results[iLast]]);
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
` + (results.length === 1 && results[0].type === "return" && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedResults(
          "Received:     ",
          expected,
          indexedResults,
          results.length === 1,
          iLast
        )) + printNumberOfReturns(countReturns(results), calls.length);
      } : () => {
        const indexedResults = [];
        if (iLast >= 0) {
          if (iLast > 0) {
            let i = iLast - 1;
            while (i >= 0 && !isEqualReturn(expected, results[i])) {
              i -= 1;
            }
            if (i < 0) {
              i = iLast - 1;
            }
            indexedResults.push([i, results[i]]);
          }
          indexedResults.push([iLast, results[iLast]]);
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
` + printReceivedResults(
          "Received: ",
          expected,
          indexedResults,
          results.length === 1,
          iLast
        ) + printNumberOfReturns(countReturns(results), calls.length);
      };
      return {
        message,
        pass
      };
    };
    var createNthCalledWithMatcher = (matcherName) => function(received, nth, ...expected) {
      const expectedArgument = "n";
      const options = {
        expectedColor: (arg) => arg,
        isNot: this.isNot,
        promise: this.promise,
        secondArgument: "...expected"
      };
      ensureMockOrSpy(received, matcherName, expectedArgument, options);
      if (!Number.isSafeInteger(nth) || nth < 1) {
        throw new Error(
          (0, _jestMatcherUtils.matcherErrorMessage)(
            (0, _jestMatcherUtils.matcherHint)(
              matcherName,
              void 0,
              expectedArgument,
              options
            ),
            `${expectedArgument} must be a positive integer`,
            (0, _jestMatcherUtils.printWithType)(
              expectedArgument,
              nth,
              _jestMatcherUtils.stringify
            )
          )
        );
      }
      const receivedIsSpy = isSpy(received);
      const receivedName = receivedIsSpy ? "spy" : received.getMockName();
      const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
      const length = calls.length;
      const iNth = nth - 1;
      const pass = iNth < length && isEqualCall(expected, calls[iNth]);
      const message = pass ? () => {
        const indexedCalls = [];
        if (iNth - 1 >= 0) {
          indexedCalls.push([iNth - 1, calls[iNth - 1]]);
        }
        indexedCalls.push([iNth, calls[iNth]]);
        if (iNth + 1 < length) {
          indexedCalls.push([iNth + 1, calls[iNth + 1]]);
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

n: ${nth}
Expected: not ${printExpectedArgs(expected)}
` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedCallsNegative(
          expected,
          indexedCalls,
          calls.length === 1,
          iNth
        )) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(
          calls.length
        )}`;
      } : () => {
        const indexedCalls = [];
        if (iNth < length) {
          if (iNth - 1 >= 0) {
            let i = iNth - 1;
            while (i >= 0 && !isEqualCall(expected, calls[i])) {
              i -= 1;
            }
            if (i < 0) {
              i = iNth - 1;
            }
            indexedCalls.push([i, calls[i]]);
          }
          indexedCalls.push([iNth, calls[iNth]]);
          if (iNth + 1 < length) {
            let i = iNth + 1;
            while (i < length && !isEqualCall(expected, calls[i])) {
              i += 1;
            }
            if (i >= length) {
              i = iNth + 1;
            }
            indexedCalls.push([i, calls[i]]);
          }
        } else if (length > 0) {
          let i = length - 1;
          while (i >= 0 && !isEqualCall(expected, calls[i])) {
            i -= 1;
          }
          if (i < 0) {
            i = length - 1;
          }
          indexedCalls.push([i, calls[i]]);
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

n: ${nth}
` + printExpectedReceivedCallsPositive(
          expected,
          indexedCalls,
          isExpand(this.expand),
          calls.length === 1,
          iNth
        ) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(
          calls.length
        )}`;
      };
      return {
        message,
        pass
      };
    };
    var createNthReturnedWithMatcher = (matcherName) => function(received, nth, expected) {
      const expectedArgument = "n";
      const options = {
        expectedColor: (arg) => arg,
        isNot: this.isNot,
        promise: this.promise,
        secondArgument: "expected"
      };
      ensureMock(received, matcherName, expectedArgument, options);
      if (!Number.isSafeInteger(nth) || nth < 1) {
        throw new Error(
          (0, _jestMatcherUtils.matcherErrorMessage)(
            (0, _jestMatcherUtils.matcherHint)(
              matcherName,
              void 0,
              expectedArgument,
              options
            ),
            `${expectedArgument} must be a positive integer`,
            (0, _jestMatcherUtils.printWithType)(
              expectedArgument,
              nth,
              _jestMatcherUtils.stringify
            )
          )
        );
      }
      const receivedName = received.getMockName();
      const { calls, results } = received.mock;
      const length = results.length;
      const iNth = nth - 1;
      const pass = iNth < length && isEqualReturn(expected, results[iNth]);
      const message = pass ? () => {
        const indexedResults = [];
        if (iNth - 1 >= 0) {
          indexedResults.push([iNth - 1, results[iNth - 1]]);
        }
        indexedResults.push([iNth, results[iNth]]);
        if (iNth + 1 < length) {
          indexedResults.push([iNth + 1, results[iNth + 1]]);
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

n: ${nth}
Expected: not ${(0, _jestMatcherUtils.printExpected)(
          expected
        )}
` + (results.length === 1 && results[0].type === "return" && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedResults(
          "Received:     ",
          expected,
          indexedResults,
          results.length === 1,
          iNth
        )) + printNumberOfReturns(countReturns(results), calls.length);
      } : () => {
        const indexedResults = [];
        if (iNth < length) {
          if (iNth - 1 >= 0) {
            let i = iNth - 1;
            while (i >= 0 && !isEqualReturn(expected, results[i])) {
              i -= 1;
            }
            if (i < 0) {
              i = iNth - 1;
            }
            indexedResults.push([i, results[i]]);
          }
          indexedResults.push([iNth, results[iNth]]);
          if (iNth + 1 < length) {
            let i = iNth + 1;
            while (i < length && !isEqualReturn(expected, results[i])) {
              i += 1;
            }
            if (i >= length) {
              i = iNth + 1;
            }
            indexedResults.push([i, results[i]]);
          }
        } else if (length > 0) {
          let i = length - 1;
          while (i >= 0 && !isEqualReturn(expected, results[i])) {
            i -= 1;
          }
          if (i < 0) {
            i = length - 1;
          }
          indexedResults.push([i, results[i]]);
        }
        return (0, _jestMatcherUtils.matcherHint)(
          matcherName,
          receivedName,
          expectedArgument,
          options
        ) + `

n: ${nth}
Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
` + printReceivedResults(
          "Received: ",
          expected,
          indexedResults,
          results.length === 1,
          iNth
        ) + printNumberOfReturns(countReturns(results), calls.length);
      };
      return {
        message,
        pass
      };
    };
    var spyMatchers = {
      lastCalledWith: createLastCalledWithMatcher("lastCalledWith"),
      lastReturnedWith: createLastReturnedMatcher("lastReturnedWith"),
      nthCalledWith: createNthCalledWithMatcher("nthCalledWith"),
      nthReturnedWith: createNthReturnedWithMatcher("nthReturnedWith"),
      toBeCalled: createToBeCalledMatcher("toBeCalled"),
      toBeCalledTimes: createToBeCalledTimesMatcher("toBeCalledTimes"),
      toBeCalledWith: createToBeCalledWithMatcher("toBeCalledWith"),
      toHaveBeenCalled: createToBeCalledMatcher("toHaveBeenCalled"),
      toHaveBeenCalledTimes: createToBeCalledTimesMatcher("toHaveBeenCalledTimes"),
      toHaveBeenCalledWith: createToBeCalledWithMatcher("toHaveBeenCalledWith"),
      toHaveBeenLastCalledWith: createLastCalledWithMatcher(
        "toHaveBeenLastCalledWith"
      ),
      toHaveBeenNthCalledWith: createNthCalledWithMatcher(
        "toHaveBeenNthCalledWith"
      ),
      toHaveLastReturnedWith: createLastReturnedMatcher("toHaveLastReturnedWith"),
      toHaveNthReturnedWith: createNthReturnedWithMatcher("toHaveNthReturnedWith"),
      toHaveReturned: createToReturnMatcher("toHaveReturned"),
      toHaveReturnedTimes: createToReturnTimesMatcher("toHaveReturnedTimes"),
      toHaveReturnedWith: createToReturnWithMatcher("toHaveReturnedWith"),
      toReturn: createToReturnMatcher("toReturn"),
      toReturnTimes: createToReturnTimesMatcher("toReturnTimes"),
      toReturnWith: createToReturnWithMatcher("toReturnWith")
    };
    var isMock = (received) => received != null && received._isMockFunction === true;
    var isSpy = (received) => received != null && received.calls != null && typeof received.calls.all === "function" && typeof received.calls.count === "function";
    var ensureMockOrSpy = (received, matcherName, expectedArgument, options) => {
      if (!isMock(received) && !isSpy(received)) {
        throw new Error(
          (0, _jestMatcherUtils.matcherErrorMessage)(
            (0, _jestMatcherUtils.matcherHint)(
              matcherName,
              void 0,
              expectedArgument,
              options
            ),
            `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
              "received"
            )} value must be a mock or spy function`,
            (0, _jestMatcherUtils.printWithType)(
              "Received",
              received,
              _jestMatcherUtils.printReceived
            )
          )
        );
      }
    };
    var ensureMock = (received, matcherName, expectedArgument, options) => {
      if (!isMock(received)) {
        throw new Error(
          (0, _jestMatcherUtils.matcherErrorMessage)(
            (0, _jestMatcherUtils.matcherHint)(
              matcherName,
              void 0,
              expectedArgument,
              options
            ),
            `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
              "received"
            )} value must be a mock function`,
            (0, _jestMatcherUtils.printWithType)(
              "Received",
              received,
              _jestMatcherUtils.printReceived
            )
          )
        );
      }
    };
    var _default = spyMatchers;
    exports.default = _default;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var conversions = require_conversions2();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var colorConvert = require_color_convert2();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser2 = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles2();
    var stdoutColor = require_browser2().stdout;
    var template = require_templates2();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = highlight;
    exports.getChalk = getChalk;
    exports.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib();
    var _chalk = require_chalk();
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return !!_chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      return options.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const chalk = getChalk(options);
        const defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;
    var _highlight = require_lib2();
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/jest-message-util/node_modules/color-name/index.js
var require_color_name3 = __commonJS({
  "node_modules/jest-message-util/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/jest-message-util/node_modules/color-convert/conversions.js
var require_conversions3 = __commonJS({
  "node_modules/jest-message-util/node_modules/color-convert/conversions.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var cssKeywords = require_color_name3();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/jest-message-util/node_modules/color-convert/route.js
var require_route3 = __commonJS({
  "node_modules/jest-message-util/node_modules/color-convert/route.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var conversions = require_conversions3();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/jest-message-util/node_modules/color-convert/index.js
var require_color_convert3 = __commonJS({
  "node_modules/jest-message-util/node_modules/color-convert/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var conversions = require_conversions3();
    var route = require_route3();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/jest-message-util/node_modules/ansi-styles/index.js
var require_ansi_styles3 = __commonJS({
  "node_modules/jest-message-util/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert3();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/jest-message-util/node_modules/supports-color/browser.js
var require_browser3 = __commonJS({
  "node_modules/jest-message-util/node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/jest-message-util/node_modules/chalk/source/util.js
var require_util3 = __commonJS({
  "node_modules/jest-message-util/node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/jest-message-util/node_modules/chalk/source/templates.js
var require_templates3 = __commonJS({
  "node_modules/jest-message-util/node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/jest-message-util/node_modules/chalk/source/index.js
var require_source2 = __commonJS({
  "node_modules/jest-message-util/node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var ansiStyles = require_ansi_styles3();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser3();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util3();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates3();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});

// node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils3();
    module.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util2();
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var fill = require_fill_range();
    var utils = require_utils3();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils3();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants3();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module.exports = braces;
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util2();
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module.exports = micromatch;
  }
});

// node_modules/slash/index.js
var require_slash = __commonJS({
  "node_modules/slash/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = (path) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path);
      if (isExtendedLengthPath || hasNonAscii) {
        return path;
      }
      return path.replace(/\\/g, "/");
    };
  }
});

// node_modules/stack-utils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/stack-utils/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var escapeStringRegexp = require_escape_string_regexp2();
    var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
    var natives = [].concat(
      require_module().builtinModules,
      "bootstrap_node",
      "node"
    ).map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(
      /\((?:node:)?internal\/[^:]+:\d+:\d+\)$/,
      /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/,
      /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/
    );
    var StackUtils = class {
      constructor(opts) {
        opts = {
          ignoredPackages: [],
          ...opts
        };
        if ("internals" in opts === false) {
          opts.internals = StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = cwd;
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(
          opts.internals,
          ignoredPackagesRegExp(opts.ignoredPackages)
        );
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { stackTraceLimit } = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Object.assign(Error, { prepareStackTrace, stackTraceLimit });
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          Object.defineProperty(res, "constructor", {
            value: true,
            configurable: true
          });
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          Object.defineProperty(res, "constructor", {
            value: true,
            configurable: true
          });
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd2) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd2}/`)) {
          filename = filename.slice(cwd2.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp(
      "^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"
    );
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module.exports = StackUtils;
  }
});

// node_modules/jest-message-util/build/index.js
var require_build6 = __commonJS({
  "node_modules/jest-message-util/build/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.separateMessageFromStack = exports.indentAllLines = exports.getTopFrame = exports.getStackTraceLines = exports.formatStackTrace = exports.formatResultsErrors = exports.formatPath = exports.formatExecError = void 0;
    var path = _interopRequireWildcard(require_path());
    var _url = require_url();
    var _codeFrame = require_lib3();
    var _chalk = _interopRequireDefault(require_source2());
    var fs = _interopRequireWildcard(require_graceful_fs());
    var _micromatch = _interopRequireDefault(require_micromatch());
    var _slash = _interopRequireDefault(require_slash());
    var _stackUtils = _interopRequireDefault(require_stack_utils());
    var _prettyFormat = require_build2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var jestReadFile = globalThis[Symbol2.for("jest-native-read-file")] || fs.readFileSync;
    var stackUtils = new _stackUtils.default({
      cwd: "something which does not exist"
    });
    var nodeInternals = [];
    try {
      nodeInternals = _stackUtils.default.nodeInternals();
    } catch {
    }
    var PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;
    var PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`;
    var JASMINE_IGNORE = /^\s+at(?:(?:.jasmine-)|\s+jasmine\.buildExpectationResult)/;
    var JEST_INTERNALS_IGNORE = /^\s+at.*?jest(-.*?)?(\/|\\)(build|node_modules|packages)(\/|\\)/;
    var ANONYMOUS_FN_IGNORE = /^\s+at <anonymous>.*$/;
    var ANONYMOUS_PROMISE_IGNORE = /^\s+at (new )?Promise \(<anonymous>\).*$/;
    var ANONYMOUS_GENERATOR_IGNORE = /^\s+at Generator.next \(<anonymous>\).*$/;
    var NATIVE_NEXT_IGNORE = /^\s+at next \(native\).*$/;
    var TITLE_INDENT = "  ";
    var MESSAGE_INDENT = "    ";
    var STACK_INDENT = "      ";
    var ANCESTRY_SEPARATOR = " \u203A ";
    var TITLE_BULLET = _chalk.default.bold("\u25CF ");
    var STACK_TRACE_COLOR = _chalk.default.dim;
    var STACK_PATH_REGEXP = /\s*at.*\(?(:\d*:\d*|native)\)?/;
    var EXEC_ERROR_MESSAGE = "Test suite failed to run";
    var NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;
    var indentAllLines = (lines) => lines.replace(NOT_EMPTY_LINE_REGEXP, MESSAGE_INDENT);
    exports.indentAllLines = indentAllLines;
    var trim = (string) => (string || "").trim();
    var trimPaths = (string) => string.match(STACK_PATH_REGEXP) ? trim(string) : string;
    var getRenderedCallsite = (fileContent, line, column) => {
      let renderedCallsite = (0, _codeFrame.codeFrameColumns)(
        fileContent,
        {
          start: {
            column,
            line
          }
        },
        {
          highlightCode: true
        }
      );
      renderedCallsite = indentAllLines(renderedCallsite);
      renderedCallsite = `
${renderedCallsite}
`;
      return renderedCallsite;
    };
    var blankStringRegexp = /^\s*$/;
    function checkForCommonEnvironmentErrors(error) {
      if (error.includes("ReferenceError: document is not defined") || error.includes("ReferenceError: window is not defined") || error.includes("ReferenceError: navigator is not defined")) {
        return warnAboutWrongTestEnvironment(error, "jsdom");
      } else if (error.includes(".unref is not a function")) {
        return warnAboutWrongTestEnvironment(error, "node");
      }
      return error;
    }
    function warnAboutWrongTestEnvironment(error, env) {
      return _chalk.default.bold.red(
        `The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline(
          "https://jestjs.io/docs/configuration#testenvironment-string"
        )}.
Consider using the "${env}" test environment.

`
      ) + error;
    }
    var formatExecError = (error, config, options, testPath, reuseMessage) => {
      if (!error || typeof error === "number") {
        error = new Error(`Expected an Error, but "${String(error)}" was thrown`);
        error.stack = "";
      }
      let message, stack;
      if (typeof error === "string" || !error) {
        error || (error = "EMPTY ERROR");
        message = "";
        stack = error;
      } else {
        message = error.message;
        stack = typeof error.stack === "string" ? error.stack : `thrown: ${(0, _prettyFormat.format)(error, {
          maxDepth: 3
        })}`;
      }
      const separated = separateMessageFromStack(stack || "");
      stack = separated.stack;
      if (separated.message.includes(trim(message))) {
        message = separated.message;
      }
      message = checkForCommonEnvironmentErrors(message);
      message = indentAllLines(message);
      stack = stack && !options.noStackTrace ? `
${formatStackTrace(stack, config, options, testPath)}` : "";
      if (typeof stack !== "string" || blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {
        message = `thrown: ${(0, _prettyFormat.format)(error, {
          maxDepth: 3
        })}`;
      }
      let messageToUse;
      if (reuseMessage) {
        messageToUse = ` ${message.trim()}`;
      } else {
        messageToUse = `${EXEC_ERROR_MESSAGE}

${message}`;
      }
      return `${TITLE_INDENT + TITLE_BULLET + messageToUse + stack}
`;
    };
    exports.formatExecError = formatExecError;
    var removeInternalStackEntries = (lines, options) => {
      let pathCounter = 0;
      return lines.filter((line) => {
        if (ANONYMOUS_FN_IGNORE.test(line)) {
          return false;
        }
        if (ANONYMOUS_PROMISE_IGNORE.test(line)) {
          return false;
        }
        if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {
          return false;
        }
        if (NATIVE_NEXT_IGNORE.test(line)) {
          return false;
        }
        if (nodeInternals.some((internal) => internal.test(line))) {
          return false;
        }
        if (!STACK_PATH_REGEXP.test(line)) {
          return true;
        }
        if (JASMINE_IGNORE.test(line)) {
          return false;
        }
        if (++pathCounter === 1) {
          return true;
        }
        if (options.noStackTrace) {
          return false;
        }
        if (JEST_INTERNALS_IGNORE.test(line)) {
          return false;
        }
        return true;
      });
    };
    var formatPath = (line, config, relativeTestPath = null) => {
      const match = line.match(/(^\s*at .*?\(?)([^()]+)(:[0-9]+:[0-9]+\)?.*$)/);
      if (!match) {
        return line;
      }
      let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2]));
      if (config.testMatch && config.testMatch.length && (0, _micromatch.default)([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {
        filePath = _chalk.default.reset.cyan(filePath);
      }
      return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);
    };
    exports.formatPath = formatPath;
    var getStackTraceLines = (stack, options = {
      noCodeFrame: false,
      noStackTrace: false
    }) => removeInternalStackEntries(stack.split(/\n/), options);
    exports.getStackTraceLines = getStackTraceLines;
    var getTopFrame = (lines) => {
      for (const line of lines) {
        if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {
          continue;
        }
        const parsedFrame = stackUtils.parseLine(line.trim());
        if (parsedFrame && parsedFrame.file) {
          if (parsedFrame.file.startsWith("file://")) {
            parsedFrame.file = (0, _slash.default)(
              (0, _url.fileURLToPath)(parsedFrame.file)
            );
          }
          return parsedFrame;
        }
      }
      return null;
    };
    exports.getTopFrame = getTopFrame;
    var formatStackTrace = (stack, config, options, testPath) => {
      const lines = getStackTraceLines(stack, options);
      let renderedCallsite = "";
      const relativeTestPath = testPath ? (0, _slash.default)(path.relative(config.rootDir, testPath)) : null;
      if (!options.noStackTrace && !options.noCodeFrame) {
        const topFrame = getTopFrame(lines);
        if (topFrame) {
          const { column, file: filename, line } = topFrame;
          if (line && filename && path.isAbsolute(filename)) {
            let fileContent;
            try {
              fileContent = jestReadFile(filename, "utf8");
              renderedCallsite = getRenderedCallsite(fileContent, line, column);
            } catch {
            }
          }
        }
      }
      const stacktrace = lines.filter(Boolean).map(
        (line) => STACK_INDENT + formatPath(trimPaths(line), config, relativeTestPath)
      ).join("\n");
      return renderedCallsite ? `${renderedCallsite}
${stacktrace}` : `
${stacktrace}`;
    };
    exports.formatStackTrace = formatStackTrace;
    var formatResultsErrors = (testResults, config, options, testPath) => {
      const failedResults = testResults.reduce((errors, result) => {
        result.failureMessages.forEach((item) => {
          errors.push({
            content: checkForCommonEnvironmentErrors(item),
            result
          });
        });
        return errors;
      }, []);
      if (!failedResults.length) {
        return null;
      }
      return failedResults.map(({ result, content }) => {
        let { message, stack } = separateMessageFromStack(content);
        stack = options.noStackTrace ? "" : `${STACK_TRACE_COLOR(
          formatStackTrace(stack, config, options, testPath)
        )}
`;
        message = indentAllLines(message);
        const title = `${_chalk.default.bold.red(
          TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : "") + result.title
        )}
`;
        return `${title}
${message}
${stack}`;
      }).join("\n");
    };
    exports.formatResultsErrors = formatResultsErrors;
    var errorRegexp = /^Error:?\s*$/;
    var removeBlankErrorLine = (str) => str.split("\n").filter((line) => !errorRegexp.test(line)).join("\n").trimRight();
    var separateMessageFromStack = (content) => {
      if (!content) {
        return {
          message: "",
          stack: ""
        };
      }
      const messageMatch = content.match(
        /^(?:Error: )?([\s\S]*?(?=\n\s*at\s.*:\d*:\d*)|\s*.*)([\s\S]*)$/
      );
      if (!messageMatch) {
        throw new Error("If you hit this error, the regex above is buggy.");
      }
      const message = removeBlankErrorLine(messageMatch[1]);
      const stack = removeBlankErrorLine(messageMatch[2]);
      return {
        message,
        stack
      };
    };
    exports.separateMessageFromStack = separateMessageFromStack;
  }
});

// node_modules/expect/build/toThrowMatchers.js
var require_toThrowMatchers = __commonJS({
  "node_modules/expect/build/toThrowMatchers.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.createMatcher = void 0;
    var _expectUtils = require_build4();
    var _jestMatcherUtils = require_build3();
    var _jestMessageUtil = require_build6();
    var _print = require_print();
    var DID_NOT_THROW = "Received function did not throw";
    var getThrown = (e) => {
      const hasMessage = e !== null && e !== void 0 && typeof e.message === "string";
      if (hasMessage && typeof e.name === "string" && typeof e.stack === "string") {
        return {
          hasMessage,
          isError: true,
          message: e.message,
          value: e
        };
      }
      return {
        hasMessage,
        isError: false,
        message: hasMessage ? e.message : String(e),
        value: e
      };
    };
    var createMatcher = (matcherName, fromPromise) => function(received, expected) {
      const options = {
        isNot: this.isNot,
        promise: this.promise
      };
      let thrown = null;
      if (fromPromise && (0, _expectUtils.isError)(received)) {
        thrown = getThrown(received);
      } else {
        if (typeof received !== "function") {
          if (!fromPromise) {
            const placeholder = expected === void 0 ? "" : "expected";
            throw new Error(
              (0, _jestMatcherUtils.matcherErrorMessage)(
                (0, _jestMatcherUtils.matcherHint)(
                  matcherName,
                  void 0,
                  placeholder,
                  options
                ),
                `${(0, _jestMatcherUtils.RECEIVED_COLOR)(
                  "received"
                )} value must be a function`,
                (0, _jestMatcherUtils.printWithType)(
                  "Received",
                  received,
                  _jestMatcherUtils.printReceived
                )
              )
            );
          }
        } else {
          try {
            received();
          } catch (e) {
            thrown = getThrown(e);
          }
        }
      }
      if (expected === void 0) {
        return toThrow(matcherName, options, thrown);
      } else if (typeof expected === "function") {
        return toThrowExpectedClass(matcherName, options, thrown, expected);
      } else if (typeof expected === "string") {
        return toThrowExpectedString(matcherName, options, thrown, expected);
      } else if (expected !== null && typeof expected.test === "function") {
        return toThrowExpectedRegExp(matcherName, options, thrown, expected);
      } else if (expected !== null && typeof expected.asymmetricMatch === "function") {
        return toThrowExpectedAsymmetric(matcherName, options, thrown, expected);
      } else if (expected !== null && typeof expected === "object") {
        return toThrowExpectedObject(matcherName, options, thrown, expected);
      } else {
        throw new Error(
          (0, _jestMatcherUtils.matcherErrorMessage)(
            (0, _jestMatcherUtils.matcherHint)(
              matcherName,
              void 0,
              void 0,
              options
            ),
            `${(0, _jestMatcherUtils.EXPECTED_COLOR)(
              "expected"
            )} value must be a string or regular expression or class or error`,
            (0, _jestMatcherUtils.printWithType)(
              "Expected",
              expected,
              _jestMatcherUtils.printExpected
            )
          )
        );
      }
    };
    exports.createMatcher = createMatcher;
    var matchers = {
      toThrow: createMatcher("toThrow"),
      toThrowError: createMatcher("toThrowError")
    };
    var toThrowExpectedRegExp = (matcherName, options, thrown, expected) => {
      const pass = thrown !== null && expected.test(thrown.message);
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected pattern: not ", expected) + (thrown !== null && thrown.hasMessage ? formatReceived(
        "Received message:     ",
        thrown,
        "message",
        expected
      ) + formatStack(thrown) : formatReceived("Received value:       ", thrown, "value")) : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected pattern: ", expected) + (thrown === null ? `
${DID_NOT_THROW}` : thrown.hasMessage ? formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Received value:   ", thrown, "value"));
      return {
        message,
        pass
      };
    };
    var toThrowExpectedAsymmetric = (matcherName, options, thrown, expected) => {
      const pass = thrown !== null && expected.asymmetricMatch(thrown.value);
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected asymmetric matcher: not ", expected) + "\n" + (thrown !== null && thrown.hasMessage ? formatReceived("Received name:    ", thrown, "name") + formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Thrown value: ", thrown, "value")) : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected asymmetric matcher: ", expected) + "\n" + (thrown === null ? DID_NOT_THROW : thrown.hasMessage ? formatReceived("Received name:    ", thrown, "name") + formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Thrown value: ", thrown, "value"));
      return {
        message,
        pass
      };
    };
    var toThrowExpectedObject = (matcherName, options, thrown, expected) => {
      const pass = thrown !== null && thrown.message === expected.message;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected message: not ", expected.message) + (thrown !== null && thrown.hasMessage ? formatStack(thrown) : formatReceived("Received value:       ", thrown, "value")) : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + (thrown === null ? formatExpected("Expected message: ", expected.message) + "\n" + DID_NOT_THROW : thrown.hasMessage ? (0, _jestMatcherUtils.printDiffOrStringify)(
        expected.message,
        thrown.message,
        "Expected message",
        "Received message",
        true
      ) + "\n" + formatStack(thrown) : formatExpected("Expected message: ", expected.message) + formatReceived("Received value:   ", thrown, "value"));
      return {
        message,
        pass
      };
    };
    var toThrowExpectedClass = (matcherName, options, thrown, expected) => {
      const pass = thrown !== null && thrown.value instanceof expected;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + (0, _print.printExpectedConstructorNameNot)(
        "Expected constructor",
        expected
      ) + (thrown !== null && thrown.value != null && typeof thrown.value.constructor === "function" && thrown.value.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)(
        "Received constructor",
        thrown.value.constructor,
        expected
      ) : "") + "\n" + (thrown !== null && thrown.hasMessage ? formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Received value: ", thrown, "value")) : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + (0, _print.printExpectedConstructorName)(
        "Expected constructor",
        expected
      ) + (thrown === null ? `
${DID_NOT_THROW}` : `${thrown.value != null && typeof thrown.value.constructor === "function" ? (0, _print.printReceivedConstructorName)(
        "Received constructor",
        thrown.value.constructor
      ) : ""}
${thrown.hasMessage ? formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Received value: ", thrown, "value")}`);
      return {
        message,
        pass
      };
    };
    var toThrowExpectedString = (matcherName, options, thrown, expected) => {
      const pass = thrown !== null && thrown.message.includes(expected);
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected substring: not ", expected) + (thrown !== null && thrown.hasMessage ? formatReceived(
        "Received message:       ",
        thrown,
        "message",
        expected
      ) + formatStack(thrown) : formatReceived("Received value:         ", thrown, "value")) : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        void 0,
        options
      ) + "\n\n" + formatExpected("Expected substring: ", expected) + (thrown === null ? `
${DID_NOT_THROW}` : thrown.hasMessage ? formatReceived("Received message:   ", thrown, "message") + formatStack(thrown) : formatReceived("Received value:     ", thrown, "value"));
      return {
        message,
        pass
      };
    };
    var toThrow = (matcherName, options, thrown) => {
      const pass = thrown !== null;
      const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        "",
        options
      ) + "\n\n" + (thrown !== null && thrown.hasMessage ? formatReceived("Error name:    ", thrown, "name") + formatReceived("Error message: ", thrown, "message") + formatStack(thrown) : formatReceived("Thrown value: ", thrown, "value")) : () => (0, _jestMatcherUtils.matcherHint)(
        matcherName,
        void 0,
        "",
        options
      ) + "\n\n" + DID_NOT_THROW;
      return {
        message,
        pass
      };
    };
    var formatExpected = (label, expected) => `${label + (0, _jestMatcherUtils.printExpected)(expected)}
`;
    var formatReceived = (label, thrown, key, expected) => {
      if (thrown === null) {
        return "";
      }
      if (key === "message") {
        const message = thrown.message;
        if (typeof expected === "string") {
          const index = message.indexOf(expected);
          if (index !== -1) {
            return `${label + (0, _print.printReceivedStringContainExpectedSubstring)(
              message,
              index,
              expected.length
            )}
`;
          }
        } else if (expected instanceof RegExp) {
          return `${label + (0, _print.printReceivedStringContainExpectedResult)(
            message,
            typeof expected.exec === "function" ? expected.exec(message) : null
          )}
`;
        }
        return `${label + (0, _jestMatcherUtils.printReceived)(message)}
`;
      }
      if (key === "name") {
        return thrown.isError ? `${label + (0, _jestMatcherUtils.printReceived)(thrown.value.name)}
` : "";
      }
      if (key === "value") {
        return thrown.isError ? "" : `${label + (0, _jestMatcherUtils.printReceived)(thrown.value)}
`;
      }
      return "";
    };
    var formatStack = (thrown) => thrown === null || !thrown.isError ? "" : (0, _jestMessageUtil.formatStackTrace)(
      (0, _jestMessageUtil.separateMessageFromStack)(thrown.value.stack).stack,
      {
        rootDir: process.cwd(),
        testMatch: []
      },
      {
        noStackTrace: false
      }
    );
    var _default = matchers;
    exports.default = _default;
  }
});

// node_modules/expect/build/index.js
var require_build7 = __commonJS({
  "node_modules/expect/build/index.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AsymmetricMatcher", {
      enumerable: true,
      get: function() {
        return _asymmetricMatchers.AsymmetricMatcher;
      }
    });
    exports.expect = exports.default = exports.JestAssertionError = void 0;
    var _expectUtils = require_build4();
    var matcherUtils = _interopRequireWildcard(require_build3());
    var _jestUtil = require_build5();
    var _asymmetricMatchers = require_asymmetricMatchers();
    var _extractExpectedAssertionsErrors = _interopRequireDefault(
      require_extractExpectedAssertionsErrors()
    );
    var _jestMatchersObject = require_jestMatchersObject();
    var _matchers = _interopRequireDefault(require_matchers());
    var _spyMatchers = _interopRequireDefault(require_spyMatchers());
    var _toThrowMatchers = _interopRequireWildcard(require_toThrowMatchers());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var Promise2 = globalThis[Symbol2.for("jest-native-promise")] || globalThis.Promise;
    var JestAssertionError = class extends Error {
      matcherResult;
    };
    exports.JestAssertionError = JestAssertionError;
    var createToThrowErrorMatchingSnapshotMatcher = function(matcher) {
      return function(received, testNameOrInlineSnapshot) {
        return matcher.apply(this, [received, testNameOrInlineSnapshot, true]);
      };
    };
    var getPromiseMatcher = (name, matcher) => {
      if (name === "toThrow" || name === "toThrowError") {
        return (0, _toThrowMatchers.createMatcher)(name, true);
      } else if (name === "toThrowErrorMatchingSnapshot" || name === "toThrowErrorMatchingInlineSnapshot") {
        return createToThrowErrorMatchingSnapshotMatcher(matcher);
      }
      return null;
    };
    var expect = (actual, ...rest) => {
      if (rest.length !== 0) {
        throw new Error("Expect takes at most one argument.");
      }
      const allMatchers = (0, _jestMatchersObject.getMatchers)();
      const expectation = {
        not: {},
        rejects: {
          not: {}
        },
        resolves: {
          not: {}
        }
      };
      const err = new JestAssertionError();
      Object.keys(allMatchers).forEach((name) => {
        const matcher = allMatchers[name];
        const promiseMatcher = getPromiseMatcher(name, matcher) || matcher;
        expectation[name] = makeThrowingMatcher(matcher, false, "", actual);
        expectation.not[name] = makeThrowingMatcher(matcher, true, "", actual);
        expectation.resolves[name] = makeResolveMatcher(
          name,
          promiseMatcher,
          false,
          actual,
          err
        );
        expectation.resolves.not[name] = makeResolveMatcher(
          name,
          promiseMatcher,
          true,
          actual,
          err
        );
        expectation.rejects[name] = makeRejectMatcher(
          name,
          promiseMatcher,
          false,
          actual,
          err
        );
        expectation.rejects.not[name] = makeRejectMatcher(
          name,
          promiseMatcher,
          true,
          actual,
          err
        );
      });
      return expectation;
    };
    exports.expect = expect;
    var getMessage = (message) => message && message() || matcherUtils.RECEIVED_COLOR("No message was specified for this matcher.");
    var makeResolveMatcher = (matcherName, matcher, isNot, actual, outerErr) => (...args) => {
      const options = {
        isNot,
        promise: "resolves"
      };
      if (!(0, _jestUtil.isPromise)(actual)) {
        throw new JestAssertionError(
          matcherUtils.matcherErrorMessage(
            matcherUtils.matcherHint(matcherName, void 0, "", options),
            `${matcherUtils.RECEIVED_COLOR("received")} value must be a promise`,
            matcherUtils.printWithType(
              "Received",
              actual,
              matcherUtils.printReceived
            )
          )
        );
      }
      const innerErr = new JestAssertionError();
      return actual.then(
        (result) => makeThrowingMatcher(matcher, isNot, "resolves", result, innerErr).apply(
          null,
          args
        ),
        (reason) => {
          outerErr.message = `${matcherUtils.matcherHint(
            matcherName,
            void 0,
            "",
            options
          )}

Received promise rejected instead of resolved
Rejected to value: ${matcherUtils.printReceived(reason)}`;
          return Promise2.reject(outerErr);
        }
      );
    };
    var makeRejectMatcher = (matcherName, matcher, isNot, actual, outerErr) => (...args) => {
      const options = {
        isNot,
        promise: "rejects"
      };
      const actualWrapper = typeof actual === "function" ? actual() : actual;
      if (!(0, _jestUtil.isPromise)(actualWrapper)) {
        throw new JestAssertionError(
          matcherUtils.matcherErrorMessage(
            matcherUtils.matcherHint(matcherName, void 0, "", options),
            `${matcherUtils.RECEIVED_COLOR(
              "received"
            )} value must be a promise or a function returning a promise`,
            matcherUtils.printWithType(
              "Received",
              actual,
              matcherUtils.printReceived
            )
          )
        );
      }
      const innerErr = new JestAssertionError();
      return actualWrapper.then(
        (result) => {
          outerErr.message = `${matcherUtils.matcherHint(
            matcherName,
            void 0,
            "",
            options
          )}

Received promise resolved instead of rejected
Resolved to value: ${matcherUtils.printReceived(result)}`;
          return Promise2.reject(outerErr);
        },
        (reason) => makeThrowingMatcher(matcher, isNot, "rejects", reason, innerErr).apply(
          null,
          args
        )
      );
    };
    var makeThrowingMatcher = (matcher, isNot, promise, actual, err) => function throwingMatcher(...args) {
      let throws = true;
      const utils = {
        ...matcherUtils,
        iterableEquality: _expectUtils.iterableEquality,
        subsetEquality: _expectUtils.subsetEquality
      };
      const matcherUtilsThing = {
        dontThrow: () => throws = false,
        equals: _expectUtils.equals,
        utils
      };
      const matcherContext = {
        ...(0, _jestMatchersObject.getState)(),
        ...matcherUtilsThing,
        error: err,
        isNot,
        promise
      };
      const processResult = (result, asyncError) => {
        _validateResult(result);
        (0, _jestMatchersObject.getState)().assertionCalls++;
        if (result.pass && isNot || !result.pass && !isNot) {
          const message = getMessage(result.message);
          let error;
          if (err) {
            error = err;
            error.message = message;
          } else if (asyncError) {
            error = asyncError;
            error.message = message;
          } else {
            error = new JestAssertionError(message);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(error, throwingMatcher);
            }
          }
          error.matcherResult = {
            ...result,
            message
          };
          if (throws) {
            throw error;
          } else {
            (0, _jestMatchersObject.getState)().suppressedErrors.push(error);
          }
        }
      };
      const handleError = (error) => {
        if (matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true && !(error instanceof JestAssertionError) && error.name !== "PrettyFormatPluginError" && Error.captureStackTrace) {
          Error.captureStackTrace(error, throwingMatcher);
        }
        throw error;
      };
      let potentialResult;
      try {
        potentialResult = matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true ? matcher.call(matcherContext, actual, ...args) : function __EXTERNAL_MATCHER_TRAP__() {
          return matcher.call(matcherContext, actual, ...args);
        }();
        if ((0, _jestUtil.isPromise)(potentialResult)) {
          const asyncError = new JestAssertionError();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(asyncError, throwingMatcher);
          }
          return potentialResult.then((aResult) => processResult(aResult, asyncError)).catch(handleError);
        } else {
          return processResult(potentialResult);
        }
      } catch (error) {
        return handleError(error);
      }
    };
    expect.extend = (matchers) => (0, _jestMatchersObject.setMatchers)(matchers, false, expect);
    expect.anything = _asymmetricMatchers.anything;
    expect.any = _asymmetricMatchers.any;
    expect.not = {
      arrayContaining: _asymmetricMatchers.arrayNotContaining,
      closeTo: _asymmetricMatchers.notCloseTo,
      objectContaining: _asymmetricMatchers.objectNotContaining,
      stringContaining: _asymmetricMatchers.stringNotContaining,
      stringMatching: _asymmetricMatchers.stringNotMatching
    };
    expect.arrayContaining = _asymmetricMatchers.arrayContaining;
    expect.closeTo = _asymmetricMatchers.closeTo;
    expect.objectContaining = _asymmetricMatchers.objectContaining;
    expect.stringContaining = _asymmetricMatchers.stringContaining;
    expect.stringMatching = _asymmetricMatchers.stringMatching;
    var _validateResult = (result) => {
      if (typeof result !== "object" || typeof result.pass !== "boolean" || result.message && typeof result.message !== "string" && typeof result.message !== "function") {
        throw new Error(
          `Unexpected return from a matcher function.
Matcher functions should return an object in the following format:
  {message?: string | function, pass: boolean}
'${matcherUtils.stringify(result)}' was returned`
        );
      }
    };
    function assertions(expected) {
      const error = new Error();
      if (Error.captureStackTrace) {
        Error.captureStackTrace(error, assertions);
      }
      (0, _jestMatchersObject.setState)({
        expectedAssertionsNumber: expected,
        expectedAssertionsNumberError: error
      });
    }
    function hasAssertions(...args) {
      const error = new Error();
      if (Error.captureStackTrace) {
        Error.captureStackTrace(error, hasAssertions);
      }
      matcherUtils.ensureNoExpected(args[0], ".hasAssertions");
      (0, _jestMatchersObject.setState)({
        isExpectingAssertions: true,
        isExpectingAssertionsError: error
      });
    }
    (0, _jestMatchersObject.setMatchers)(_matchers.default, true, expect);
    (0, _jestMatchersObject.setMatchers)(_spyMatchers.default, true, expect);
    (0, _jestMatchersObject.setMatchers)(_toThrowMatchers.default, true, expect);
    expect.assertions = assertions;
    expect.hasAssertions = hasAssertions;
    expect.getState = _jestMatchersObject.getState;
    expect.setState = _jestMatchersObject.setState;
    expect.extractExpectedAssertionsErrors = _extractExpectedAssertionsErrors.default;
    var _default = expect;
    exports.default = _default;
  }
});
export default require_build7();
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
//# sourceMappingURL=expect.js.map
